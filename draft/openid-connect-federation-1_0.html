<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>OpenID Connect Federation 1.0 - draft 17 </title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Overall Architecture">
<link href="#rfc.section.3" rel="Chapter" title="3 Components">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Entity Statement">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Trust Chain">
<link href="#rfc.section.4" rel="Chapter" title="4 Metadata">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 RP Metadata">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 OP Metadata">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 OAuth Authorization Server">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 OAuth Client">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 OAuth Protected Resource">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Federation Entity">
<link href="#rfc.section.5" rel="Chapter" title="5 Federation Policy">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Metadata Policy">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Operators">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Restrictions on Policy Entries">
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Combining Policies">
<link href="#rfc.section.5.1.3.1" rel="Chapter" title="5.1.3.1 Merging Operators">
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 Applying Policies">
<link href="#rfc.section.5.1.5" rel="Chapter" title="5.1.5 Policy Combination Example">
<link href="#rfc.section.5.1.6" rel="Chapter" title="5.1.6 Enforcing Policy">
<link href="#rfc.section.5.1.7" rel="Chapter" title="5.1.7 Extending the Policy Language">
<link href="#rfc.section.5.1.8" rel="Chapter" title="5.1.8 Policy Example">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Applying Constraints">
<link href="#rfc.section.5.2.1" rel="Chapter" title="5.2.1 Max Path Length">
<link href="#rfc.section.5.2.2" rel="Chapter" title="5.2.2 Naming Constraints">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Trust Marks">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Trust Mark Claims">
<link href="#rfc.section.5.3.2" rel="Chapter" title="5.3.2 Validating a Trust Mark">
<link href="#rfc.section.5.3.3" rel="Chapter" title="5.3.3 Trust Mark Example">
<link href="#rfc.section.6" rel="Chapter" title="6 Obtaining Federation Entity Configuration Information">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Federation Entity Configuration Request">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Federation Entity Configuration Response">
<link href="#rfc.section.7" rel="Chapter" title="7 Federation API">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Fetching Entity Statements (REQUIRED)">
<link href="#rfc.section.7.1.1" rel="Chapter" title="7.1.1 Fetch Entity Statements Request">
<link href="#rfc.section.7.1.2" rel="Chapter" title="7.1.2 Fetch Entity Statements Response">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Trust Negotiation (OPTIONAL)">
<link href="#rfc.section.7.2.1" rel="Chapter" title="7.2.1 Trust Negotiation Request">
<link href="#rfc.section.7.2.2" rel="Chapter" title="7.2.2 Trust Negotiation Response">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Entity Listings (OPTIONAL)">
<link href="#rfc.section.7.3.1" rel="Chapter" title="7.3.1 Entity Listings Request">
<link href="#rfc.section.7.3.2" rel="Chapter" title="7.3.2 Entity Listing Response">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Generic Error Response">
<link href="#rfc.section.8" rel="Chapter" title="8 Resolving Trust Chain and Metadata">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Fetching Entity Statements to Establish a Trust Chain">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Validating a Trust Chain">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Choosing One of the Valid Trust Chains">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Calculating the Expiration Time of a Trust Chain">
<link href="#rfc.section.9" rel="Chapter" title="9 Updating Metadata, Key Rollover, and Revocation">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Protocol Key Rollover">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Key Rollover for a Trust Anchor">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Revocation">
<link href="#rfc.section.10" rel="Chapter" title="10 OpenID Connect Communication">
<link href="#rfc.section.10.1" rel="Chapter" title="10.1 Automatic Registration">
<link href="#rfc.section.10.1.1" rel="Chapter" title="10.1.1 Authentication Request">
<link href="#rfc.section.10.1.1.1" rel="Chapter" title="10.1.1.1 Using a Request Object">
<link href="#rfc.section.10.1.1.1.1" rel="Chapter" title="10.1.1.1.1 Processing the Authentication Request">
<link href="#rfc.section.10.1.1.2" rel="Chapter" title="10.1.1.2 Using Pushed Authorization">
<link href="#rfc.section.10.1.1.2.1" rel="Chapter" title="10.1.1.2.1 Processing the Authentication Request">
<link href="#rfc.section.10.1.2" rel="Chapter" title="10.1.2 Authentication Error Response">
<link href="#rfc.section.10.2" rel="Chapter" title="10.2 Explicit Registration">
<link href="#rfc.section.10.2.1" rel="Chapter" title="10.2.1 Client Registration">
<link href="#rfc.section.10.2.1.1" rel="Chapter" title="10.2.1.1 Client Registration Request">
<link href="#rfc.section.10.2.1.2" rel="Chapter" title="10.2.1.2 Client Registration Response">
<link href="#rfc.section.10.2.1.2.1" rel="Chapter" title="10.2.1.2.1 OP Constructing the Response">
<link href="#rfc.section.10.2.1.2.2" rel="Chapter" title="10.2.1.2.2 RP Parsing the Response">
<link href="#rfc.section.10.2.2" rel="Chapter" title="10.2.2 After Client Registration">
<link href="#rfc.section.10.2.2.1" rel="Chapter" title="10.2.2.1 What the RP MUST Do">
<link href="#rfc.section.10.2.2.2" rel="Chapter" title="10.2.2.2 What the OP MUST Do">
<link href="#rfc.section.10.2.3" rel="Chapter" title="10.2.3 Expiration Times">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Provider Information Discovery and Client Registration in a Federation">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Setting Up a Federation">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 The LIGO Wiki Discovers the OP's Metadata">
<link href="#rfc.appendix.A.2.1" rel="Chapter" title="A.2.1 Configuration Information for op.umu.se">
<link href="#rfc.appendix.A.2.2" rel="Chapter" title="A.2.2 Configuration Information for 'https://umu.se'">
<link href="#rfc.appendix.A.2.3" rel="Chapter" title="A.2.3 Entity Statement Published by 'https://umu.se' about 'https://op.umu.se'">
<link href="#rfc.appendix.A.2.4" rel="Chapter" title="A.2.4 Configuration Information for 'https://swamid.se'">
<link href="#rfc.appendix.A.2.5" rel="Chapter" title="A.2.5 Entity Statement Published by 'https://swamid.se' about 'https://umu.se'">
<link href="#rfc.appendix.A.2.6" rel="Chapter" title="A.2.6 Configuration Information for 'https://edugain.geant.org'">
<link href="#rfc.appendix.A.2.7" rel="Chapter" title="A.2.7 Entity Statement Published by 'https://edugain.geant.org' about 'https://swamid.se'">
<link href="#rfc.appendix.A.2.8" rel="Chapter" title="A.2.8 Verified Metadata for op.umu.se">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 The Two Ways of Doing Client Registration">
<link href="#rfc.appendix.A.3.1" rel="Chapter" title="A.3.1 RP Sends Authentication Request (Automatic Registration)">
<link href="#rfc.appendix.A.3.1.1" rel="Chapter" title="A.3.1.1 OP Fetches Entity Statements">
<link href="#rfc.appendix.A.3.1.2" rel="Chapter" title="A.3.1.2 OP Evaluates the RP Metadata">
<link href="#rfc.appendix.A.3.2" rel="Chapter" title="A.3.2 Client Starts with Registration (Explicit Client Registration)">
<link href="#rfc.appendix.B" rel="Chapter" title="B Notices">
<link href="#rfc.appendix.C" rel="Chapter" title="C Acknowledgements">
<link href="#rfc.appendix.D" rel="Chapter" title="D Open Issues">
<link href="#rfc.appendix.E" rel="Chapter" title="E Document History">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 3.9.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Hedberg, R., Ed., Jones, M., Solberg, A., Gulliksson, S., and J. Bradley" />
  <meta name="dct.identifier" content="urn:ietf:id:openid-connect-federation-1_0" />
  <meta name="dct.issued" scheme="ISO8601" content="2021-09-09" />
  <meta name="dct.abstract" content="A federation can be expressed as an agreement between parties that trust each other.  In bilateral federations, you can have direct trust between the parties.  In a multilateral federation, bilateral agreements might not be practical, in which case, trust can be mediated by a third party.  That is the model used in this specification.   An entity in the federation must be able to trust that other entities it is interacting with belong to the same federation.  It must also be able to trust that the information the other entities publish about themselves has not been tampered with during transport and that it adheres to the federation&#x27;s policies.   This specification describes the basic components you will need to build a multilateral federation and it provides a guide on how to apply them when the underlying protocol used is OpenID Connect.   " />
  <meta name="description" content="A federation can be expressed as an agreement between parties that trust each other.  In bilateral federations, you can have direct trust between the parties.  In a multilateral federation, bilateral agreements might not be practical, in which case, trust can be mediated by a third party.  That is the model used in this specification.   An entity in the federation must be able to trust that other entities it is interacting with belong to the same federation.  It must also be able to trust that the information the other entities publish about themselves has not been tampered with during transport and that it adheres to the federation&#x27;s policies.   This specification describes the basic components you will need to build a multilateral federation and it provides a guide on how to apply them when the underlying protocol used is OpenID Connect.   " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left"></td>
<td class="right">R. Hedberg, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">independent</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Jones</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Microsoft</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">A. Solberg</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Uninett</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">S. Gulliksson</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Schibsted</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Bradley</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Yubico</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">September 9, 2021</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">OpenID Connect Federation 1.0 - draft 17 <br />
  <span class="filename">openid-connect-federation-1_0</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>A federation can be expressed as an agreement between parties that trust each other.  In bilateral federations, you can have direct trust between the parties.  In a multilateral federation, bilateral agreements might not be practical, in which case, trust can be mediated by a third party.  That is the model used in this specification.  </p>
<p>An entity in the federation must be able to trust that other entities it is interacting with belong to the same federation.  It must also be able to trust that the information the other entities publish about themselves has not been tampered with during transport and that it adheres to the federation's policies.  </p>
<p>This specification describes the basic components you will need to build a multilateral federation and it provides a guide on how to apply them when the underlying protocol used is OpenID Connect.  </p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Overall Architecture</a>
</li>
<li>3.   <a href="#rfc.section.3">Components</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Entity Statement</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Trust Chain</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Metadata</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">RP Metadata</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">OP Metadata</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">OAuth Authorization Server</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">OAuth Client</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">OAuth Protected Resource</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Federation Entity</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Federation Policy</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Metadata Policy</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Operators</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Restrictions on Policy Entries</a>
</li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Combining Policies</a>
</li>
<ul><li>5.1.3.1.   <a href="#rfc.section.5.1.3.1">Merging Operators</a>
</li>
</ul><li>5.1.4.   <a href="#rfc.section.5.1.4">Applying Policies</a>
</li>
<li>5.1.5.   <a href="#rfc.section.5.1.5">Policy Combination Example</a>
</li>
<li>5.1.6.   <a href="#rfc.section.5.1.6">Enforcing Policy</a>
</li>
<li>5.1.7.   <a href="#rfc.section.5.1.7">Extending the Policy Language</a>
</li>
<li>5.1.8.   <a href="#rfc.section.5.1.8">Policy Example</a>
</li>
</ul><li>5.2.   <a href="#rfc.section.5.2">Applying Constraints</a>
</li>
<ul><li>5.2.1.   <a href="#rfc.section.5.2.1">Max Path Length</a>
</li>
<li>5.2.2.   <a href="#rfc.section.5.2.2">Naming Constraints</a>
</li>
</ul><li>5.3.   <a href="#rfc.section.5.3">Trust Marks</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Trust Mark Claims</a>
</li>
<li>5.3.2.   <a href="#rfc.section.5.3.2">Validating a Trust Mark</a>
</li>
<li>5.3.3.   <a href="#rfc.section.5.3.3">Trust Mark Example</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Obtaining Federation Entity Configuration Information</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Federation Entity Configuration Request</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Federation Entity Configuration Response</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Federation API</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Fetching Entity Statements (REQUIRED)</a>
</li>
<ul><li>7.1.1.   <a href="#rfc.section.7.1.1">Fetch Entity Statements Request</a>
</li>
<li>7.1.2.   <a href="#rfc.section.7.1.2">Fetch Entity Statements Response</a>
</li>
</ul><li>7.2.   <a href="#rfc.section.7.2">Trust Negotiation (OPTIONAL)</a>
</li>
<ul><li>7.2.1.   <a href="#rfc.section.7.2.1">Trust Negotiation Request</a>
</li>
<li>7.2.2.   <a href="#rfc.section.7.2.2">Trust Negotiation Response</a>
</li>
</ul><li>7.3.   <a href="#rfc.section.7.3">Entity Listings (OPTIONAL)</a>
</li>
<ul><li>7.3.1.   <a href="#rfc.section.7.3.1">Entity Listings Request</a>
</li>
<li>7.3.2.   <a href="#rfc.section.7.3.2">Entity Listing Response</a>
</li>
</ul><li>7.4.   <a href="#rfc.section.7.4">Generic Error Response</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Resolving Trust Chain and Metadata</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Fetching Entity Statements to Establish a Trust Chain</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Validating a Trust Chain</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Choosing One of the Valid Trust Chains</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">Calculating the Expiration Time of a Trust Chain</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Updating Metadata, Key Rollover, and Revocation</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Protocol Key Rollover</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Key Rollover for a Trust Anchor</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Revocation</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">OpenID Connect Communication</a>
</li>
<ul><li>10.1.   <a href="#rfc.section.10.1">Automatic Registration</a>
</li>
<ul><li>10.1.1.   <a href="#rfc.section.10.1.1">Authentication Request</a>
</li>
<ul><li>10.1.1.1.   <a href="#rfc.section.10.1.1.1">Using a Request Object</a>
</li>
<ul><li>10.1.1.1.1.   <a href="#rfc.section.10.1.1.1.1">Processing the Authentication Request</a>
</li>
</ul><li>10.1.1.2.   <a href="#rfc.section.10.1.1.2">Using Pushed Authorization</a>
</li>
<ul><li>10.1.1.2.1.   <a href="#rfc.section.10.1.1.2.1">Processing the Authentication Request</a>
</li>
</ul></ul><li>10.1.2.   <a href="#rfc.section.10.1.2">Authentication Error Response</a>
</li>
</ul><li>10.2.   <a href="#rfc.section.10.2">Explicit Registration</a>
</li>
<ul><li>10.2.1.   <a href="#rfc.section.10.2.1">Client Registration</a>
</li>
<ul><li>10.2.1.1.   <a href="#rfc.section.10.2.1.1">Client Registration Request</a>
</li>
<li>10.2.1.2.   <a href="#rfc.section.10.2.1.2">Client Registration Response</a>
</li>
<ul><li>10.2.1.2.1.   <a href="#rfc.section.10.2.1.2.1">OP Constructing the Response</a>
</li>
<li>10.2.1.2.2.   <a href="#rfc.section.10.2.1.2.2">RP Parsing the Response</a>
</li>
</ul></ul><li>10.2.2.   <a href="#rfc.section.10.2.2">After Client Registration</a>
</li>
<ul><li>10.2.2.1.   <a href="#rfc.section.10.2.2.1">What the RP MUST Do</a>
</li>
<li>10.2.2.2.   <a href="#rfc.section.10.2.2.2">What the OP MUST Do</a>
</li>
</ul><li>10.2.3.   <a href="#rfc.section.10.2.3">Expiration Times</a>
</li>
</ul></ul><li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<ul><li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Provider Information Discovery and Client Registration in a Federation</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Setting Up a Federation</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">The LIGO Wiki Discovers the OP's Metadata</a>
</li>
<ul><li>A.2.1.   <a href="#rfc.appendix.A.2.1">Configuration Information for op.umu.se</a>
</li>
<li>A.2.2.   <a href="#rfc.appendix.A.2.2">Configuration Information for 'https://umu.se'</a>
</li>
<li>A.2.3.   <a href="#rfc.appendix.A.2.3">Entity Statement Published by 'https://umu.se' about 'https://op.umu.se'</a>
</li>
<li>A.2.4.   <a href="#rfc.appendix.A.2.4">Configuration Information for 'https://swamid.se'</a>
</li>
<li>A.2.5.   <a href="#rfc.appendix.A.2.5">Entity Statement Published by 'https://swamid.se' about 'https://umu.se'</a>
</li>
<li>A.2.6.   <a href="#rfc.appendix.A.2.6">Configuration Information for 'https://edugain.geant.org'</a>
</li>
<li>A.2.7.   <a href="#rfc.appendix.A.2.7">Entity Statement Published by 'https://edugain.geant.org' about 'https://swamid.se'</a>
</li>
<li>A.2.8.   <a href="#rfc.appendix.A.2.8">Verified Metadata for op.umu.se</a>
</li>
</ul><li>A.3.   <a href="#rfc.appendix.A.3">The Two Ways of Doing Client Registration</a>
</li>
<ul><li>A.3.1.   <a href="#rfc.appendix.A.3.1">RP Sends Authentication Request (Automatic Registration)</a>
</li>
<ul><li>A.3.1.1.   <a href="#rfc.appendix.A.3.1.1">OP Fetches Entity Statements</a>
</li>
<li>A.3.1.2.   <a href="#rfc.appendix.A.3.1.2">OP Evaluates the RP Metadata</a>
</li>
</ul><li>A.3.2.   <a href="#rfc.appendix.A.3.2">Client Starts with Registration (Explicit Client Registration)</a>
</li>
</ul></ul><li>Appendix B.   <a href="#rfc.appendix.B">Notices</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Acknowledgements</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">Open Issues</a>
</li>
<li>Appendix E.   <a href="#rfc.appendix.E">Document History</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#Introduction" id="Introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This specification describes how two entities that would like to interact can dynamically fetch and resolve trust and metadata for a given protocol through the use of third-party trust anchor. A trust anchor is an entity whose main purpose is to issue statements about entities, such as OpenID Connect Relying Parties, OpenID Providers, and participating organizations.  An identity federation can be realized using this specification using one or more levels of trust issuers. This specification does not mandate a specific way or restrict how a federation may be built. Instead, the specification provides the basic technical trust infrastructure building blocks needed to build a dynamic and distributed trust network such as a federation.  </p>
<p id="rfc.section.1.p.2">Note that this specification only concerns itself with how entities in a federation get to know about each other.  Furthermore, note that a company, as with any real-world organization, MAY be represented by more than one entity in a federation.  It is also true that an entity can be part of more than one federation.  </p>
<p id="rfc.section.1.p.3">OpenID Connect Federation trust chains rely on cryptographically signed <a href="#RFC7519" class="xref">JSON Web Token (JWT)</a> documents, and the trust chain does not at all rely on TLS <a href="#RFC8446" class="xref">[RFC8446]</a> to establish trust.  </p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.  </p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> Terminology</h1>
<p id="rfc.section.1.2.p.1">This specification uses the terms "Claim Name", "Claim Value", "JSON Web Token (JWT)", defined by <a href="#RFC7519" class="xref">JSON Web Token (JWT)</a> and the terms "OpenID Provider (OP)" and "Relying Party (RP)" defined by <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a>.  </p>
<p id="rfc.section.1.2.p.2">This specification also defines the following terms: </p>

<dl>
<dt>Entity</dt>
<dd style="margin-left: 8">
<br> Something that has a separate and distinct existence and that can be identified in a context. All entities in an OpenID Connect federation MUST have a globally unique identifier.  </dd>
<dt>Entity identifier</dt>
<dd style="margin-left: 8">
<br> An URI that is globally unique and that is bound to one Entity.  </dd>
<dt>Entity statement</dt>
<dd style="margin-left: 8">
<br> An entity statement is issued by an entity, which pertains to a subject entity and leaf entities. An entity statement is always a signed JWT.  </dd>
<dt>Intermediate entity</dt>
<dd style="margin-left: 8">
<br> An entity that issues an entity statement that appears somewhere in between those issued by the trust anchor and the leaf entity in a trust chain.  </dd>
<dt>Leaf Entity</dt>
<dd style="margin-left: 8">
<br> An entity defined by a certain protocol, e.g., OpenID Connect Relying Party or Provider.  </dd>
<dt>Trust Anchor</dt>
<dd style="margin-left: 8">
<br> An entity that represents a trusted third party.  </dd>
<dt>Trust Chain</dt>
<dd style="margin-left: 8">
<br> A sequence of entity statements that represents a chain starting at a leaf entity and ending in a trust anchor.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#architecture" id="architecture">Overall Architecture</a>
</h1>
<p id="rfc.section.2.p.1">The basic component is the entity statement, which is a cryptographically signed <a href="#RFC7519" class="xref">JSON Web Token (JWT)</a>.  A set of entity statements can form a path from a leaf entity to a trust anchor. This is done by having authority hints in an entity statement pointing to its nearest superiors. Starting with an entity statement, you can then find the next level of entity statements by following the authority hints. And then repeat this until you hit a trust anchor.  </p>
<p id="rfc.section.2.p.2">Once you have followed a path, you have collected a set of entity statements that forms a chain. You can verify that this chain has not been tampered with by verifying the signature of each statement. How this is done is described in <a href="#trust_chain" class="xref">Section 3.2</a>.  </p>
<p id="rfc.section.2.p.3">With a verified trust chain in hand, you can now apply federation policy to the published metadata. How this is done is described in <a href="#federation_policy" class="xref">Section 5</a>.  </p>
<p id="rfc.section.2.p.4">Note that this specification is only dealing with trust in that the other party is part of the same federation as you and that you can trust that the metadata you get that describes the other party is what was sent. The specification does not touch protocol operations outside those of metadata exchange. In OpenID Connect terms, these are protocol operations other than discovery and registration.  </p>
<p id="rfc.section.2.p.5">The fact that we use OpenID Connect in all the examples in this specification does not mean that the specification can only be used together with OpenID Connect. On the contrary, it can equally well be used to build an OAuth 2.0 federations or for that matter, other protocols that depend on dynamic exchange of entity metadata.  </p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#components" id="components">Components</a>
</h1>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#entity-statement" id="entity-statement">Entity Statement</a>
</h1>
<p id="rfc.section.3.1.p.1">An entity statement is issued by an entity and concerns a subject entity and leaf entities in a federation. An entity statement is always a signed JWT.  All entities in a federation SHOULD be prepared to publish an entity statement about themselves. If they are not able to do so themselves someone else MUST do it for them.  </p>
<p id="rfc.section.3.1.p.2">An entity statement is composed of the following claims: </p>
<p></p>

<p>The following is a non-normative example of a <samp>trust_marks_issuers</samp> claim value: </p>
<pre>
{
  "https://openid.net/certification/op": ["*"],
  "https://refeds.org/wp-content/uploads/2016/01/Sirtfi-1.0.pdf":
    ["https://swamid.sunet.se"]
}
              </pre>
<dl>
<dt>iss</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The entity identifier of the issuer of the statement. If the <samp>iss</samp> and the <samp>sub</samp> are identical, the issuer is making a statement about itself.  </dd>
<dt>sub</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The entity identifier of the subject </dd>
<dt>iat</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The time the statement was issued.  Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.  See <a href="#RFC3339" class="xref">RFC 3339</a> for details regarding date/times in general and UTC in particular.  </dd>
<dt>exp</dt>
<dd style="margin-left: 8">
<br> REQUIRED.  Expiration time on or after which the statement MUST NOT be accepted for processing. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.  </dd>
<dt>jwks</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. A <a href="#RFC7517" class="xref">JSON Web Key Set (JWKS)</a> representing the public part of the subject entity's signing keys. The corresponding private key is used by leaf entities to sign entity statements about themselves, and intermediate entities to sign statements about other entities.  The keys that can be found here are primarily intended to sign entity statements and SHOULD NOT be used in other protocols.  This claim is only OPTIONAL for the entity statement returned from an OP when the client is doing explicit registration.  In all other cases it is REQUIRED.  Every JWK in the JWK Set MUST have a Key ID (kid).  </dd>
<dt>aud</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  The entity statement MAY be specifically created for an entity.  The entity identifier for that entity MUST appear in this claim.  </dd>
<dt>authority_hints</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. Array of strings representing the entity identifiers of intermediate entities or trust anchors that MAY issue an entity statement about the issuer entity.  For all entities except for trust anchors that do not have any superiors this is REQUIRED and MUST NOT be the empty list [].  This claim MUST be absent from an entity statement issued by a trust anchor with no superiors.  </dd>
<dt>metadata</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. JSON object including protocol specific metadata claims that represent the entity's metadata.  Each key of the JSON object represents a metadata type identifier, and each value MUST be a JSON object representing the metadata according to the metadata schema of that metadata type. An entity statement MAY contain multiple metadata statements, but only one for each metadata type.  If the <samp>iss</samp> of an entity statement points to the same entity as the <samp>sub</samp>, then the entity statement MUST contain a <samp>metadata</samp> claim.  If <samp>iss</samp> and <samp>sub</samp> are not the same, then the entity statement MUST NOT contain a <samp>metadata</samp> claim.  </dd>
<dt>metadata_policy</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. JSON object that describes a metadata policy.  Each key of the JSON object represents a metadata type identifier, and each value MUST be a JSON object representing the metadata policy according to the metadata schema of that metadata type. An entity statement MAY contain multiple metadata policy statements, but only one for each metadata type.  Only non-leaf entities MAY contain a <samp>metadata_policy</samp> claim. Leaf entities MUST NOT contain a <samp>metadata_policy</samp> claim.  </dd>
<dt>constraints</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. JSON object that describes a set of trust chain constraints. There is more about this in <a href="#chain_constraints" class="xref">Section 5.2</a>.  </dd>
<dt>crit</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  The <samp>crit</samp> (critical) entity statement claim indicates that extensions to entity statement claims defined by this specification are being used that MUST be understood and processed.  It is used in the same way that <samp>crit</samp> is used for extension <a href="#RFC7515" class="xref">JWS</a> header parameters that MUST be understood and processed.  Its value is an array listing the entity statement claims present in the entity statement that use those extensions.  If any of the listed extension entity statement claims are not understood and supported by the recipient, then the entity statement is invalid.  Producers MUST NOT include entity statement claim names defined by this specification or names that do not occur as entity statement claim names in the entity statement in the <samp>crit</samp> list.  Producers MUST NOT use the empty list <samp>[]</samp> as the <samp>crit</samp> value.  </dd>
<dt>policy_language_crit</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  The <samp>policy_language_crit</samp> (critical) entity statement claim indicates that extensions to the policy language defined by this specification are being used that MUST be understood and processed.  It is used in the same way that <samp>crit</samp> is used for extension <a href="#RFC7515" class="xref">JSON Web Signature (JWS)</a> header parameters that MUST be understood and processed.  Its value is an array listing the policy language extensions present in the policy language statements that use those extensions.  If any of the listed extension policy language extensions are not understood and supported by the recipient, then the entity statement is invalid.  Producers MUST NOT include policy language names defined by this specification or names that do not occur in policy language statements in the entity statement in the <samp>policy_language_crit</samp> list.  Producers MUST NOT use the empty list <samp>[]</samp> as the <samp>policy_language_crit</samp> value.  </dd>
<dt>trust_marks</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. A JSON array of signed JSON Web Tokens, each representing a certification mark. There is more about certification marks in <a href="#trust_marks" class="xref">Section 5.3</a>.  </dd>
<dt>trust_marks_issuers</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  A trust anchor MAY use this claim to tell which trust mark identifiers and their issuers are trusted by the federation.  This claim MUST be ignored if present in an entity statement of other entities than trust anchor.  It is a JSON array with keys representing trust mark identifiers and values being an array of trusted entities representing the accreditation authority.  A special value of <samp>*</samp> allows for self-signed trust marks.  There is more about certification marks in <a href="#trust_marks" class="xref">Section 5.3</a>.  </dd>
<dt>trust_anchor_id</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  An OP MUST use this claim to tell the RP which trust anchor it chose to use when responding to an explicit client registration.  The value of <samp>trust_anchor_id</samp> is the entity identifier of a trust anchor.  </dd>
</dl>

<p> </p>
<p id="rfc.section.3.1.p.4">The entity statement is signed using the private key of the issuer entity, in the form of a <a href="#RFC7515" class="xref">JSON Web Signature (JWS)</a>. Entities MUST support signing Entity Statements with the RSA SHA-256 algorithm (an <samp>alg</samp> value of <samp>RS256</samp>). Consequently entities MUST support signature verification where the statement was signed using RS256.  </p>
<p>The following is a non-normative example of an entity statement before serialization and adding a signature. The example contains a critical extension <samp>jti</samp> (JWT ID) to the entity statement and one critical extension to the policy language <samp>regexp</samp> (Regular expression).  </p>
<pre>
{
  "iss": "https://feide.no",
  "sub": "https://ntnu.no",
  "iat": 1516239022,
  "exp": 1516298022,
  "crit": ["jti"],
  "jti": "7l2lncFdY6SlhNia",
  "policy_language_crit": ["regexp"],
  "metadata_policy": {
    "openid_provider": {
      "issuer": {"value": "https://ntnu.no"},
      "organization_name": {"value": "NTNU"},
      "id_token_signing_alg_values_supported":
        {"subset_of": ["RS256", "RS384", "RS512"]},
      "op_policy_uri": {
        "regexp":
          "^https:\/\/[\\w-]+\\.example\\.com\/[\\w-]+\\.html"}
    },
    "openid_relying_party": {
      "organization_name": {"value": "NTNU"},
      "grant_types_supported": {
        "subset_of": ["authorization_code", "implicit"]},
      "scopes": {
        "subset_of": ["openid", "profile", "email", "phone"]}
    }
  },
  "constraints": {
    "max_path_length": 2
  },
  "jwks": {
    "keys": [
      {
        "alg": "RS256",
        "e": "AQAB",
        "key_ops": ["verify"],
        "kid": "key1",
        "kty": "RSA",
        "n": "pnXBOusEANuug6ewezb9J_...",
        "use": "sig"
      }
    ]
  },
  "authority_hints": [
    "https://edugain.org/federation"
  ]
}
</pre>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#trust_chain" id="trust_chain">Trust Chain</a>
</h1>
<p id="rfc.section.3.2.p.1">In an OpenID Connect Identity Federation, entities that together build a trust chain can be categorized as: </p>

<dl>
<dt>Trust anchor</dt>
<dd style="margin-left: 8">
<br> An entity that represents a trusted third party.  </dd>
<dt>Leaf</dt>
<dd style="margin-left: 8">
<br> In an OpenID Connect Identity Federation, an RP or an OP.  </dd>
<dt>Intermediate</dt>
<dd style="margin-left: 8">
<br> Neither a leaf nor a trust anchor.  </dd>
</dl>

<p> </p>
<p id="rfc.section.3.2.p.2">A trust chain begins with a leaf entity's self-signed entity statement, has zero or more entity statements issued by intermediates about subordinates, and ends with an entity statement issued by the trust anchor about the top-most intermediate (if there are intermediates) or the leaf entity (if there are no intermediates).  </p>
<p id="rfc.section.3.2.p.3">A simple example: If we have an RP that belongs to organization A that is a member of federation F, the trust chain for such a setup will contain the following entity statements: </p>

<ol>
<li>a self-signed entity statement about the RP published by the RP, </li>
<li>an entity statement about the RP published by Organization A, and </li>
<li>an entity statement about Organization A published by Federation.  F </li>
</ol>

<p> </p>
<p id="rfc.section.3.2.p.4">A trust chain MUST always be possible to order such that: If we name the entity statements ES[0] (the leaf entity's self-signed entity statement) to ES[i] (an entity statement issued by the trust anchor), i&gt;0 then: </p>

<ul>
<li>The <samp>iss</samp> entity in one entity statement is always the <samp>sub</samp> entity in the next.  ES[j]['iss'] == ES[j+1]['sub'], j=0,...,i-1 .  </li>
<li>There MUST always be a signing key carried in the <samp>jwks</samp> claim in ES[j] that can be used to verify the signature of ES[j-1], j=i,...,1 .  </li>
<li>It MUST be possible to verify the signature of ES[0] with one of the keys in ES[0]['jwks'].  </li>
</ul>

<p> </p>
<p id="rfc.section.3.2.p.5">The signing key that MUST be used to verify ES[i] is distributed from the trust anchors to any entity that needs to verify a trust chain in some secure out-of-band way not described in this document.  </p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#metadata" id="metadata">Metadata</a>
</h1>
<p id="rfc.section.4.p.1">This specification does allow new metadata types to be defined, to support use cases outside OpenID Connect federations.  The metadata type identifier will uniquely identify which metadata specification to utilize.  </p>
<p id="rfc.section.4.p.2">The metadata document MUST be a JSON document. Beyond that there is no restriction.  </p>
<p id="rfc.section.4.p.3">Metadata used in federations typically reuses existing metadata standards.  If needed, the metadata schema is extended with additional properties relevant in a federated context.  For instance, for OpenID Connect Federations, this specification uses metadata values from <a href="#OpenID.Discovery" class="xref">OpenID Connect Discovery 1.0</a> and <a href="#OpenID.Registration" class="xref">OpenID Connect Dynamic Client Registration 1.0</a> and adds additional values used for federations.  </p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#RP_metadata" id="RP_metadata">RP Metadata</a>
</h1>
<p id="rfc.section.4.1.p.1">The metadata type identifier is <samp>openid_relying_party</samp>.  </p>
<p id="rfc.section.4.1.p.2">All parameters defined in Section 2 of <a href="#OpenID.Registration" class="xref">OpenID Connect Dynamic Client Registration 1.0</a> are allowed in a metadata statement.  </p>
<p id="rfc.section.4.1.p.3">To that list is added: </p>

<dl>
<dt>client_registration_types</dt>
<dd style="margin-left: 8">
<br> REQUIRED. Array of strings specifying the client registration types the RP wants to use. Values defined by this specification are <samp>automatic</samp> and <samp>explicit</samp>.  </dd>
<dt>organization_name</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. A human-readable name representing the organization owning the RP.  </dd>
<dt>signed_jwks_uri</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. A URI pointing to a signed JWT having the entity's JWK Set as payload. The JWT is signed with a key that was included in the JWK that the entity published in its self-signed entity statement.  A signed JWT can contain the following claims, all except <samp>keys</samp> defined in <a href="#RFC7519" class="xref">[RFC7519]</a>: <dl>
<dt>keys</dt>
<dd style="margin-left: 8">
<br> REQUIRED. List of JWKs.  </dd>
<dt>iss</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The "iss" (issuer) claim identifies the principal that issued the JWT.  </dd>
<dt>sub</dt>
<dd style="margin-left: 8">
<br> REQUIRED. This claim identifies the owner of the keys.  It SHOULD be the same as the issuer.  </dd>
<dt>iat</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. This claim identifies the time at which the JWT was issued.  </dd>
<dt>exp</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. This claim identifies the time at which the JWT is no longer valid.  </dd>
</dl>
<p> There are more claims defined in </p>
<a href="#RFC7519" class="xref">[RFC7519]</a>; of these, <samp>aud</samp> SHOULD NOT be used, since the issuer cannot know who the audience is.  <samp>nbf</samp> and <samp>jti</samp> are deemed to not be very useful in this context and are therefore to be omitted.  </dd>
</dl>

<p> </p>
<p>The following is a non-normative example of a signed JWKS before serialization and adding a signature.  </p>
<pre>
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "SUdtUndEWVY2cUFDeDV5NVlBWDhvOXJodVl2am1mNGNtR0pmd",
      "n": "y_Zc8rByfeRIC9fFZrDZ2MGH2ZnxLrc0ZNNwkNet5rwCPYeRF3Sv
            5nihZA9NHkDTEX97dN8hG6ACfeSo6JB2P7heJtmzM8oOBZbmQ90n
            EA_JCHszkejHaOtDDfxPH6bQLrMlItF4JSUKua301uLB7C8nzTxm
            tF3eAhGCKn8LotEseccxsmzApKRNWhfKDLpKPe9i9PZQhhJaurwD
            kMwbWTAeZbqCScU1o09piuK1JDf2PaDFevioHncZcQO74Obe4nN3
            oNPNAxrMClkZ9s9GMEd5vMqOD4huXlRpHwm9V3oJ3LRutOTxqQLV
            yPucu7eHA7her4FOFAiUk-5SieXL9Q",
      "e": "AQAB"
    },
    {
      "kty": "EC",
      "kid": "MFYycG1raTI4SkZvVDBIMF9CNGw3VEZYUmxQLVN2T21nSWlkd3",
      "crv": "P-256",
      "x": "qAOdPQROkHfZY1daGofOmSNQWpYK8c9G2m2Rbkpbd4c",
      "y": "G_7fF-T8n2vONKM15Mzj4KR_shvHBxKGjMosF6FdoPY"
    }
  ],
  "iss": "https://example.org/op",
  "iat": 1618410883
}
</pre>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#OP_metadata" id="OP_metadata">OP Metadata</a>
</h1>
<p id="rfc.section.4.2.p.1">The metadata type identifier is <samp>openid_provider</samp>.  </p>
<p id="rfc.section.4.2.p.2">All parameters defined in Section 3 of <a href="#OpenID.Discovery" class="xref">OpenID Connect Discovery 1.0</a> are applicable.  </p>
<p id="rfc.section.4.2.p.3">In addition, the following parameters are defined by this specification: </p>
<p></p>

<dl>
<dt>client_registration_types_supported</dt>
<dd style="margin-left: 8">
<br> REQUIRED. Array specifying the federation types supported.  Federation type values defined by this specification are <samp>automatic</samp> and <samp>explicit</samp>.  </dd>
<dt>organization_name</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. A human-readable name representing the organization owning the OP. It is intended to be used in the user interface, being recognized by the end users that would be using the OP to authenticate.  </dd>
<dt>federation_registration_endpoint</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  URL of the OP's Federation specific Dynamic Client Registration Endpoint. If the OP supports explicit client registration as described in <a href="#explicit" class="xref">Section 10.2</a>, then this claim is REQUIRED.  </dd>
<dt>request_authentication_methods_supported</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  In OpenID Connect Core, no client authentication is performed at the authentication endpoint. Instead, you can say that a request authentication is performed. What it amounts to is that the OP maps the information in the request to the information it has on the client, through static or dynamic registration.  If the map is successful, then the request is permitted to proceed.  Something similar happens when automatic registration is used.  Since there has been no explicit registration, the OP will gather information about the RP using the process outlined in <a href="#federation_configuration" class="xref">Section 6</a>. Once it has the RP metadata, the OP can verify the information the RP provides in the request. We make this a bit more secure by demanding the use of the request parameter or pushed authorization.  <br> The claim value is a JSON object with members representing processes/endpoints and as values lists of request authentication methods that are supported by the authorization endpoint.  In this specification we use the processes/endpoints: Authorization Request (AR) as described in Section 3 of <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a> and Pushed Authorization Request (PAR), as described in <a href="#PAR" class="xref">[PAR]</a>.  The request authentication methods are: <dl>
<dt>request_object</dt>
<dd style="margin-left: 8">
<br> This uses a Request Object as described in <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a>.  There is more about this in <a href="#automatic" class="xref">Section 10.1</a>.  </dd>
<dt>private_key_jwt</dt>
<dd style="margin-left: 8">
<br> The authentication process is described in Section 9 of <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a>.  Note that if <samp>private_key_jwt</samp> is used, the audience of the signed JWT MUST be either the URL of the Authorization Server's Authorization Endpoint or the Authorization Server's entity identifier.  </dd>
<dt>tls_client_auth</dt>
<dd style="margin-left: 8">
<br> Section 2.1 of <a href="#RFC8705" class="xref">[RFC8705]</a>.  </dd>
<dt>self_signed_tls_client_auth</dt>
<dd style="margin-left: 8">
<br> Section 2.2 of <a href="#RFC8705" class="xref">[RFC8705]</a>.  </dd>
</dl>
<p> The only request authentication method that can be used if doing authentication as described in </p>
<a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a> is <samp>request_object</samp>.  If pushed authorization is used then one of <samp>private_key_jwt</samp>, <samp>tls_client_auth</samp> and <samp>self_signed_tls_client_auth</samp> can be used.  </dd>
<dt>signed_jwks_uri</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. A URI pointing to a signed JWT having the entity's JWK Set as payload. The JWT is signed with a key that was included in the JWK that the entity published in its self-signed entity statement.  </dd>
</dl>

<p> </p>
<p id="rfc.section.4.2.p.5">The following is a non-normative example of OP metadata:' </p>
<pre>
{
  "issuer": "https://server.example.com",
  "authorization_endpoint":
    "https://server.example.com/authorization",
  "token_endpoint": "https://server.example.com/token",
  "signed_jwks_uri": "https://server.example.com/jws.json",
  "response_types_supported": ["code", "id_token", "id_token token"],
  "subject_types_supported": ["public"],
  "id_token_signing_alg_values_supported": ["RS256", "ES256"],
  "token_endpoint_auth_methods_supported": ["private_key_jwt"],
  "pushed_authorization_request_endpoint":
    "https://server.example.com/par",
  "client_registration_types_supported": ["automatic", "explicit"],
  "federation_registration_endpoint":
    "https://server.example.com/fedreg",
  "request_authentication_methods_supported": {
    "ar": ["request_object"],
    "par": ["private_key_jwt", "self_signed_tls_client_auth"]
  }
}
</pre>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> OAuth Authorization Server</h1>
<p id="rfc.section.4.3.p.1">The metadata type identifier is <samp>oauth_authorization_server</samp>.  </p>
<p id="rfc.section.4.3.p.2">All parameters defined in Section 2 of <a href="#RFC8414" class="xref">RFC 8414</a> are applicable.  </p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> OAuth Client</h1>
<p id="rfc.section.4.4.p.1">The metadata type identifier is <samp>oauth_client</samp>.  </p>
<p id="rfc.section.4.4.p.2">All parameters defined in Section 2 of <a href="#RFC7591" class="xref">RFC 7591</a> are applicable.  </p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> OAuth Protected Resource</h1>
<p id="rfc.section.4.5.p.1">The metadata type identifier is <samp>oauth_resource</samp>.  There is no standard that specifies what parameters can occur in the metadata for this kind of entity. So for the time being, this can be regarded as a placeholder.  </p>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> Federation Entity</h1>
<p id="rfc.section.4.6.p.1">The metadata type identifier is <samp>federation_entity</samp>.  </p>
<p id="rfc.section.4.6.p.2">All entities participating in a federation are of this type.  </p>
<p id="rfc.section.4.6.p.3">The following properties are allowed: </p>

<dl>
<dt>federation_api_endpoint</dt>
<dd style="margin-left: 8">
<br> OPTIONAL.  The endpoint for the Federation API described in <a href="#federation_api" class="xref">Section 7</a>. Intermediate entities and trust anchors MUST publish a <samp>federation_api_endpoint</samp>.  Leaf entities MUST NOT.  </dd>
<dt>name</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. String. The human-readable name describing the subject entity. This MAY be, for example, the name of an organization.  </dd>
<dt>contacts</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. JSON array with one or more strings representing contact persons at the entity.  These MAY contain names, e-mail addresses, descriptions, phone numbers, etc.  </dd>
<dt>policy_uri</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. URL to documentation of conditions and policies relevant to this entity.  </dd>
<dt>homepage_uri</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. URL to a generic home page representing this entity.  </dd>
<dt>trust_marks</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. A JSON array of signed JSON Web Token each representing a certification mark. There is more about certification marks in <a href="#trust_marks" class="xref">Section 5.3</a>.  </dd>
</dl>

<p> </p>
<p id="rfc.section.4.6.p.4">Example</p>
<pre>
"federation_entity": {
  "federation_api_endpoint":
    "https://example.com/federation_api_endpoint",
  "name": "The example cooperation",
  "homepage_uri": "https://www.example.com"
}
</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#federation_policy" id="federation_policy">Federation Policy</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#metadata_policy" id="metadata_policy">Metadata Policy</a>
</h1>
<p id="rfc.section.5.1.p.1">An entity can publish metadata policies pertaining to entities of a specific type. Entity type identifiers specified in this document can be found in <a href="#metadata" class="xref">Section 4</a>.  </p>
<p id="rfc.section.5.1.p.2">Each such metadata policy has the following structure: </p>

<ul>
<li>It consists of one or more policy entries.</li>
<li>Each policy entry applies to one metadata parameter, such as <samp>id_token_signing_alg</samp>.  </li>
<li>Each policy entry consists of one or more operators, which can be value modifiers or value checks.  </li>
<li>An operator can only appear once in a policy entry.</li>
</ul>

<p> </p>
<p id="rfc.section.5.1.p.3">It SHOULD be noted that claim names without language tags are different from the same claim but with language tags.  </p>
<p></p>

<p>An example of a policy entry: </p>
<pre>
"id_token_signing_alg": {
  "default": "ES256",
  "one_of" : ["ES256", "ES384", "ES512"]
}
</pre>
<p></p>

<p>Which fits into a metadata policy like this: </p>
<pre>
"metadata_policy" : {
  "openid_relying_party": {
    "id_token_signing_alg": {
      "default": "ES256",
      "one_of" : ["ES256", "ES384", "ES512"]
    }
  }
}
</pre>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> Operators</h1>
<p id="rfc.section.5.1.1.p.1">Value modifiers are: </p>

<dl>
<dt>value</dt>
<dd style="margin-left: 8">
<br> Disregarding what value the parameter had, if any, the parameter's value will be set to the operator's value.  </dd>
<dt>add</dt>
<dd style="margin-left: 8">
<br> Adds the value or values specified to the metadata parameter.  If any of the specified values are already present as values of the parameter, they will not be added.  If the parameter has no value, then the parameter is initialized with the specified value(s).  </dd>
<dt>default</dt>
<dd style="margin-left: 8">
<br> If no value is assigned to this parameter, then the parameter's value will be set to the operator's value(s).  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.1.1.p.2">Value checks are: </p>

<dl>
<dt>one_of</dt>
<dd style="margin-left: 8">
<br> The value of the parameter MUST be one of the ones listed in this directive.  </dd>
<dt>subset_of</dt>
<dd style="margin-left: 8">
<br> The resulting value of the parameter will be the intersection of the values in the directive and the values of the parameter.  </dd>
<dt>superset_of</dt>
<dd style="margin-left: 8">
<br> The values of the parameter MUST contain the ones in the directive.  We define superset the mathematical way, that is, equality is included.  </dd>
<dt>essential</dt>
<dd style="margin-left: 8">
<br> If <samp>true</samp>, then the parameter MUST have a value.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#policy_restr" id="policy_restr">Restrictions on Policy Entries</a>
</h1>
<p id="rfc.section.5.1.2.p.1">As stated, a policy entry can contain one or more operators.  Not all operators are allowed to appear together in a policy entry.  </p>
<p></p>

<dl>
<dt>subset_of/superset_of and one_of</dt>
<dd style="margin-left: 8">
<br> <samp>subset_of</samp> and <samp>superset_of</samp> applies to parameters that can have more than one value (for instance, <samp>contacts</samp>) while <samp>one_of</samp> applies to parameters that can only have one value (for instance, <samp>id_token_signed_response_alg</samp>).  This means that <samp>one_of</samp> cannot appear beside <samp>subset_of</samp>/ <samp>superset_of</samp> in a policy entry.  </dd>
<dt>value</dt>
<dd style="margin-left: 8">
<br> <samp>value</samp> overrides everything else.  So having <samp>value</samp> together with any other operator (except for <samp>essential</samp>) does not make sense.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.1.2.p.3">Other restrictions are: </p>
<p></p>

<ul>
<li>If <samp>subset_of</samp> and <samp>superset_of</samp> both appear as operators, then the list of values in <samp>subset_of</samp> MUST be a superset of the values in <samp>superset_of</samp>.  </li>
<li>If <samp>add</samp> appears in a policy entry together with <samp>subset_of</samp> then the value/values of <samp>add</samp> MUST be a subset of <samp>subset_of</samp>.  </li>
<li>If <samp>add</samp> appears in a policy entry together with <samp>superset_of</samp> then the values of <samp>add</samp> MUST be a superset of <samp>superset_of</samp>.  </li>
<li>If <samp>default</samp> appears in a policy entry together with <samp>subset_of</samp> then the values of <samp>default</samp> MUST be a subset of <samp>subset_of</samp>.  </li>
<li>If <samp>default</samp> appears in a policy entry together with <samp>superset_of</samp> then the values of <samp>default</samp> MUST be a superset of <samp>superset_of</samp>.  </li>
<li>If <samp>add</samp> appears in a policy entry together with <samp>one_of</samp> then the value of <samp>add</samp> MUST be a member of <samp>one_of</samp>.  </li>
<li>If <samp>default</samp> appears in a policy entry together with <samp>one_of</samp> then the value <samp>default</samp> MUST be a member of <samp>one_of</samp>.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.5.1.3">
<a href="#rfc.section.5.1.3">5.1.3.</a> Combining Policies</h1>
<p id="rfc.section.5.1.3.p.1">If there is more than one metadata policy in a trust chain, then the policies MUST be combined before they are applied to the metadata statement.  </p>
<p id="rfc.section.5.1.3.p.2">Using the notation we have defined in <a href="#trust_chain" class="xref">Section 3.2</a>, policies are combined starting with ES[i] and then adding the policies from ES[j] j=i-1,..,1 before applying the combined policy to the entity's metadata.  </p>
<p id="rfc.section.5.1.3.p.3">After each combination, the policy for each parameter MUST adhere to the rules defined in <a href="#policy_restr" class="xref">Section 5.1.2</a>.  </p>
<h1 id="rfc.section.5.1.3.1">
<a href="#rfc.section.5.1.3.1">5.1.3.1.</a> Merging Operators</h1>
<p></p>

<dl>
<dt>subset_of</dt>
<dd style="margin-left: 8">
<br> The result of merging the values of two <samp>subset_of</samp> operators is the intersection of the operator values.  </dd>
<dt>one_of</dt>
<dd style="margin-left: 8">
<br> The result of merging the values of two <samp>one_of</samp> operators is the intersection of the operator values.  </dd>
<dt>superset_of</dt>
<dd style="margin-left: 8">
<br> The result of merging the values of two <samp>superset_of</samp> operators is the union of the operator values.  </dd>
<dt>add</dt>
<dd style="margin-left: 8">
<br> The result of merging the values of two <samp>add</samp> operators is the union of the values.  </dd>
<dt>value</dt>
<dd style="margin-left: 8">
<br> Merging two <samp>value</samp> operators is NOT allowed unless the two operator values are equal.  </dd>
<dt>default</dt>
<dd style="margin-left: 8">
<br> Merging two <samp>default</samp> operators is NOT allowed unless the two operator values are equal.  </dd>
<dt>essential</dt>
<dd style="margin-left: 8">
<br> If a superior has specified <samp>essential=true</samp>, then a subordinate cannot change that. If a superior has specified <samp>essential=false</samp>, then a subordinate is allowed to change that to <samp>essential=true</samp>.  If a superior has not specified <samp>essential</samp>, then a subordinate can set <samp>essential</samp> to <samp>true</samp> or <samp>false</samp>.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.5.1.4">
<a href="#rfc.section.5.1.4">5.1.4.</a> Applying Policies</h1>
<p id="rfc.section.5.1.4.p.1">Once combining the Metadata policies has been accomplished, the next step is to apply the combined policy to the metadata.  </p>
<p id="rfc.section.5.1.4.p.2">Doing that, one follows these steps for each parameter in the policy.  </p>
<p></p>

<ol>
<li>If there is a <samp>value</samp> operator in the policy, apply that and you are done.  </li>
<li>Add whatever value is specified in an <samp>add</samp> operator.  </li>
<li>If the parameter still has no value apply the <samp>default</samp> if there is one.  </li>
<li>Do the essential check. If <samp>essential</samp> is missing as an operator <samp>essential</samp> is to be treated as if set to <samp>false</samp>.  If <samp>essential</samp> is defined to be <samp>true</samp>, then the claim MUST have a value by now. Otherwise applying the operator MUST fail.  </li>
<li>Do the other checks. Verified that the value is <samp>one_of</samp> or that the values are <samp>subset_of</samp>/<samp>superset_of</samp>. If the parameter values do not fall within the allowed boundaries, applying the operator MUST fail.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.5.1.5">
<a href="#rfc.section.5.1.5">5.1.5.</a> Policy Combination Example</h1>
<p>A federation's policy for RPs: </p>
<pre>
{
  "scopes": {
    "subset_of": [
      "openid",
      "eduperson",
      "phone"
    ],
    "superset_of": [
      "openid"
    ],
    "default": [
      "openid",
      "eduperson"
    ]
  },
  "id_token_signed_response_alg": {
    "one_of": [
      "ES256",
      "ES384",
      "ES512"
    ]
  },
  "contacts": {
    "add": "helpdesk@federation.example.org"
  },
  "application_type": {
    "value": "web"
  }
}
</pre>
<p>An organization's policy for RPs: </p>
<pre>
{
  "scopes": {
    "subset_of": [
      "openid",
      "eduperson",
      "address"
    ],
    "default": [
      "openid",
      "eduperson"
    ]
  },
  "id_token_signed_response_alg": {
    "one_of": [
      "ES256",
      "ES384"
    ],
    "default": "ES256"
  },
  "contacts": {
    "add": "helpdesk@org.example.org"
  }
}
</pre>
<p>The combined metadata policy then becomes: </p>
<pre>
{
  "scopes": {
    "subset_of": [
      "openid",
      "eduperson"
    ],
    "superset_of": [
      "openid"
    ],
    "default": [
      "openid",
      "eduperson"
    ]
  },
  "id_token_signed_response_alg": {
    "one_of": [
      "ES256",
      "ES384"
    ],
    "default": "ES256"
  },
  "contacts": {
    "add": [
      "helpdesk@federation.example.org",
      "helpdesk@org.example.org"
    ]
  },
  "application_type": {
    "value": "web"
  }
}
</pre>
<h1 id="rfc.section.5.1.6">
<a href="#rfc.section.5.1.6">5.1.6.</a> Enforcing Policy</h1>
<p id="rfc.section.5.1.6.p.1">If applying policies to a metadata statement results in incorrect metadata, then such a metadata statement MUST be regarded as broken and MUST NOT be used.  </p>
<h1 id="rfc.section.5.1.7">
<a href="#rfc.section.5.1.7">5.1.7.</a> Extending the Policy Language</h1>
<p id="rfc.section.5.1.7.p.1">There might be parties that want to extend the policy language defined here. If that happens then the rule is that if software compliant with this specification encounters a keyword it does not understand, it MUST ignore it unless it is listed in a <samp>policy_language_crit</samp> list, as is done for <a href="#RFC7515" class="xref">JWS</a> header parameters with the <samp>crit</samp> parameter.  If the policy language extension keyword is listed in the <samp>policy_language_crit</samp> list and not understood, then the metadata MUST be rejected.  </p>
<h1 id="rfc.section.5.1.8">
<a href="#rfc.section.5.1.8">5.1.8.</a> Policy Example</h1>
<p id="rfc.section.5.1.8.p.1">The following is a non-normative example of a set of policies being applied to an RP's metadata.  </p>
<p>The RP's metadata: </p>
<pre>
{
  "contacts": [
    "rp_admins@cs.example.com"
  ],
  "redirect_uris": [
    "https://cs.example.com/rp1"
  ],
  "response_types": [
    "code"
  ]
}
</pre>
<p>The federation's policy for RPs: </p>
<pre>
{
  "scopes": {
    "superset_of": [
      "openid",
      "eduperson"
    ],
    "default": [
      "openid",
      "eduperson"
    ]
  },
  "response_types": {
    "subset_of": [
      "code",
      "code id_token"
    ]
  }
}
</pre>
<p>The organization's policy for RPs: </p>
<pre>
{
  "contacts": {
    "add": "helpdesk@example.com"
  },
  "logo_uri": {
    "one_of": [
      "https://example.com/logo_small.jpg",
      "https://example.com/logo_big.jpg"
    ],
    "default": "https://example.com/logo_small.jpg"
  },
  "policy_uri": {
    "value": "https://example.com/policy.html"
  },
  "tos_uri": {
    "value": "https://example.com/tos.html"
  }
}
</pre>
<p id="rfc.section.5.1.8.p.2">The metadata for the entity in question, after applying the policies above, would then become: </p>
<pre>
{
  "contacts": [
    "rp_admins@cs.example.com",
    "helpdesk@example.com"
  ],
  "logo_uri": "https://example.com/logo_small.jpg",
  "policy_uri": "https://example.com/policy.html",
  "tos_uri": "https://example.com/tos.html",
  "scopes": [
    "openid",
    "eduperson"
  ],
  "response_types": [
    "code"
  ],
  "redirect_uris": [
    "https://cs.example.com/rp1"
  ]
}
</pre>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#chain_constraints" id="chain_constraints">Applying Constraints</a>
</h1>
<p id="rfc.section.5.2.p.1">A constraint specification can contain the following claims:</p>
<p></p>

<dl>
<dt>max_path_length</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. Integer. The maximum number of entity statements between this entity statement and the last entity statement in the trust chain.  </dd>
<dt>naming_constraints</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. JSON object. Restriction on the entity identifiers of the entities below this entity. The behavior of this claim mimics what is defined in Section 4.2.1.10 in <a href="#RFC5280" class="xref">[RFC5280]</a>.  Restrictions are defined in terms of permitted or excluded name subtrees.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.2.p.3">The following is a non-normative example of such a specification:</p>
<pre>
{
  "naming_constraints": {
    "permitted": [
      "https://.example.com"
    ],
    "excluded": [
      "https://east.example.com"
    ]
  },
  "max_path_length": 2
}
</pre>
<p id="rfc.section.5.2.p.4">If a subordinate entity statement contains a constraint specification that is more restrictive than the one in effect, then the more restrictive constraint is in effect from here on.  </p>
<p id="rfc.section.5.2.p.5">If a subordinate entity statement contains a constraint specification that is less restrictive than the one in effect, then it MUST be ignored.  </p>
<h1 id="rfc.section.5.2.1">
<a href="#rfc.section.5.2.1">5.2.1.</a> <a href="#max_path_length" id="max_path_length">Max Path Length</a>
</h1>
<p id="rfc.section.5.2.1.p.1">The <samp>max_path_length</samp> constraint specifies the maximum number of entity statement a trust chain can have between the entity statement that contains the constraint specification and the leaf's entity statement.  </p>
<p id="rfc.section.5.2.1.p.2">A <samp>max_path_length</samp> constraint of zero indicates that no entity statement MAY appear between this entity statement and the leaf entity statement. Where it appears, the <samp>max_path_length</samp> constraint MUST have a value that is greater than or equal to zero.  Where <samp>max_path_length</samp> does not appear, no limit is imposed.  </p>
<p id="rfc.section.5.2.1.p.3">Assuming that we have a trust chain with four entity statements: </p>

<ol>
<li>Leaf entity (LE)</li>
<li>Intermediate 1 (I1)</li>
<li>Intermediate 2 (I2)</li>
<li>Trust Anchor (TA)</li>
</ol>

<p> </p>
<p id="rfc.section.5.2.1.p.4">Then the trust chain fulfills the constraints if: </p>

<ul>
<li>The TA specifies a <samp>max_path_length</samp> that is equal to or bigger than 2.  </li>
<li>TA specifies <samp>max_path_length</samp> of 2, I2 specifies <samp>max_path_length</samp> of 1, and I1 specifies no <samp>max_path_length</samp> constraint.  </li>
<li>Neither TA nor I2 specifies any <samp>max_path_length</samp> constraint while I1 specifies <samp>max_path_length</samp> of 0.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.2.1.p.5">The trust chain does not fulfill the constraints if: </p>

<ul><li>TA has specified <samp>max_path_length</samp> of 1.  </li></ul>

<p> </p>
<h1 id="rfc.section.5.2.2">
<a href="#rfc.section.5.2.2">5.2.2.</a> <a href="#naming_constraints" id="naming_constraints">Naming Constraints</a>
</h1>
<p id="rfc.section.5.2.2.p.1">The <samp>naming_constraints</samp> member specifies a namespace within which all subject entity identifiers in subordinate entity statements in a trust chain MUST be located.  </p>
<p id="rfc.section.5.2.2.p.2">Restrictions are defined in terms of permitted or excluded name subtrees. Any name matching a restriction in the excluded claim is invalid regardless of information appearing in the permitted claim.  </p>
<p id="rfc.section.5.2.2.p.3">The constraint MUST be specified as a fully qualified domain name and MAY specify a host or a domain. Examples would be "host.example.com" and ".example.com". When the constraint begins with a period, it MAY be expanded with one or more labels.  That is, the constraint ".example.com" is satisfied by both host.example.com and my.host.example.com. However, the constraint ".example.com" is not satisfied by "example.com". When the constraint does not begin with a period, it specifies a host.  </p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#trust_marks" id="trust_marks">Trust Marks</a>
</h1>
<p id="rfc.section.5.3.p.1">In this specification we use the US NSTIC definition: "A trustmark is used to indicate that a product or service provider has met the requirements of the Identity Ecosystem, as determined by an accreditation authority".  </p>
<p id="rfc.section.5.3.p.2">Technically, trust marks as used by this specification are signed JWTs that represent a statement of conformance to a well-scoped set of trust and/or interoperability requirements.  </p>
<p id="rfc.section.5.3.p.3">The trust marks are signed by a federation accredited authority. The validation of such a signed statement is performed in the same way that a self-signed entity statement is validated.  </p>
<p id="rfc.section.5.3.p.4">Note that a federation MAY allow an entity to self-sign some trust marks.  </p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#trust_mark_claims" id="trust_mark_claims">Trust Mark Claims</a>
</h1>
<p id="rfc.section.5.3.1.p.1">These are the properties that can occur in a trust mark:</p>
<p></p>

<dl>
<dt>iss</dt>
<dd style="margin-left: 8">
<br> REQUIRED. String. The issuer of the trust mark.  </dd>
<dt>sub</dt>
<dd style="margin-left: 8">
<br> REQUIRED. String. The entity this trust mark applies to.  </dd>
<dt>id</dt>
<dd style="margin-left: 8">
<br> REQUIRED. String. An identifier of the trust mark.  </dd>
<dt>iat</dt>
<dd style="margin-left: 8">
<br> REQUIRED. Number. When this trust mark was issued.  Expressed as Seconds Since the Epoch, per <a href="#RFC7519" class="xref">[RFC7519]</a>.  </dd>
<dt>mark</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. String. An URL that points to a mark/logo that the subject is allowed to display to a user of the entity.  </dd>
<dt>exp</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. Number. When this trust mark is not valid anymore.  Expressed as Seconds Since the Epoch, per <a href="#RFC7519" class="xref">[RFC7519]</a>.  If not present, it means that the trust mark is valid forever.  </dd>
<dt>ref</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. String. URL that points to information connected to the issuance of this trust mark.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.3.1.p.3">Other claims MAY be used in conjunction with the claims outlined above.  The claim naming recommendations outlined in Section 5.1.2 of <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a> apply.  </p>
<h1 id="rfc.section.5.3.2">
<a href="#rfc.section.5.3.2">5.3.2.</a> <a href="#trust_valid" id="trust_valid">Validating a Trust Mark</a>
</h1>
<p id="rfc.section.5.3.2.p.1">An entity SHOULD NOT try to validate a trust mark until it knows which trust anchors it wants to use.  </p>
<p id="rfc.section.5.3.2.p.2">Validating a trust mark follows the procedure set out in <a href="#resolving_trust" class="xref">Section 8</a>.  </p>
<p id="rfc.section.5.3.2.p.3">Note that the entity representing the accreditation authority SHOULD be well known and trusted for a given trust mark identifier.  A trust anchor MAY publish a list of accreditation authorities of trust marks that SHOULD be trusted by other federation entities.  A trust anchor uses the <samp>trust_marks_issuers</samp> claim in its entity statement to publish this information.  </p>
<p id="rfc.section.5.3.2.p.4">For other externally issued trust marks, it is an out-of-band process to define and announce accreditation authorities to other entities and it is left to the discretion of the receiving party to assign an appropriate level of trust to such trust marks.  </p>
<h1 id="rfc.section.5.3.3">
<a href="#rfc.section.5.3.3">5.3.3.</a> <a href="#trust_example" id="trust_example">Trust Mark Example</a>
</h1>
<p>An example of a self-signed certification mark:</p>
<pre>
{
  "iss": "https://example.com/op",
  "sub": "https://example.com/op",
  "iat": 1579621160,
  "id": "https://openid.net/certification/op",
  "mark": "http://openid.net/wordpress-content/uploads/2016/
    05/oid-l-certification-mark-l-cmyk-150dpi-90mm.jpg",
  "ref": "https://openid.net/wordpress-content/uploads/2015/
    09/RolandHedberg-pyoidc-0.7.7-Basic-26-Sept-2015.zip"
}
</pre>
<p>An example of a third-party accreditation authority: </p>
<pre>
{
  "iss": "https://swamid.sunet.se",
  "sub": "https://umu.se/op",
  "iat": 1577833200,
  "exp": 1609369200,
  "id":
    "https://refeds.org/wp-content/uploads/2016/01/Sirtfi-1.0.pdf"
}
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#federation_configuration" id="federation_configuration">Obtaining Federation Entity Configuration Information</a>
</h1>
<p id="rfc.section.6.p.1">The configuration endpoint is found using the <a href="#RFC8615" class="xref">Well-Known URIs</a> specification, with the suffix <samp>openid-federation</samp>. The scheme, host, and port are taken directly from the entity identifier combined with the following path: <samp>/.well-known/openid-federation</samp>.  </p>
<p id="rfc.section.6.p.2">If the entity identifier contains a path, it is concatenated after <samp>/.well-known/openid-federation</samp> in the same manner that path components are concatenated to the well-known identifier in the OAuth 2.0 Authorization Server Metadata <a href="#RFC8414" class="xref">[RFC8414]</a> specification.  Of course, in real multi-tenant deployments, in which the entity identifier might be of the form <samp>https://multi-tenant-service.example.com/my-tenant-identifier</samp> the tenant is very likely to not have control over the path <samp>https://multi-tenant-service.example.com/.well-known/openid-federation/my-tenant-identifier</samp> whereas it is very likely to have control over the path <samp>https://multi-tenant-service.example.com/my-tenant-identifier/.well-known/openid-federation</samp>.  Therefore, if using the configuration endpoint at the URL with the tenant path after the well-known part fails, it is RECOMMENDED that callers retry at the URL with the tenant path before the well-known part (even though this violates <a href="#RFC8615" class="xref">[RFC8615]</a>).  </p>
<p id="rfc.section.6.p.3">Federation Entities SHOULD make an Entity Configuration Document available at the configuration endpoint. There is only one exception to this rule and that is for an RP that only does explicit registration. Since it posts the self-signed entity statement to the OP during client registration, the OP has everything it needs from the RP.  </p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Federation Entity Configuration Request</h1>
<p id="rfc.section.6.1.p.1">A federation Entity Configuration Document MUST be queried using an HTTP GET request at the previously specified path.  The requesting party would make the following request to the Entity <samp>https://example.com</samp> to obtain its Configuration information: </p>
<pre>

  GET /.well-known/openid-federation HTTP/1.1
  Host: example.com
</pre>
<p></p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Federation Entity Configuration Response</h1>
<p id="rfc.section.6.2.p.1">The response is a self-signed Entity Statement, as described in <a href="#entity-statement" class="xref">Section 3.1</a>.  If the entity is an intermediate entity or a trust anchor, the response MUST contain metadata for a federation entity.  </p>
<p id="rfc.section.6.2.p.2">A positive response is a signed entity statement, where the content type MUST be set to <samp>application/jose</samp>.  In case of an error, the response will be a JSON object, the content type MUST be set to <samp>application/json</samp>, and the error response uses the applicable HTTP status code value.  </p>
<p id="rfc.section.6.2.p.3">The following is a non-normative example response from an intermediate entity, before serialization and adding a signature: </p>
<pre>
200 OK
Last-Modified: Thu, 29 Aug 2019 08:54:26 GMT
Content-Type: application/jose

{
  "iss": "https://example.com",
  "sub": "https://example.com",
  "iat": 1516239022,
  "exp": 1516298022,
  "metadata": {
    "federation_entity": {
      "federation_api_endpoint":
        "https://example.com/federation_api_endpoint",
      "name": "The example cooperation",
      "homepage_uri": "https://www.example.com"
    }
  },
  "authority_hints": ["https://federation.example.com"],
  "jwks": {
    "keys": [
      {
        "alg": "RS256",
        "e": "AQAB",
        "key_ops": [
          "verify"
        ],
        "kid": "key1",
        "kty": "RSA",
        "n": "pnXBOusEANuug6ewezb9J_...",
        "use": "sig"
      }
    ]
  }
}
</pre>
<p></p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#federation_api" id="federation_api">Federation API</a>
</h1>
<p id="rfc.section.7.p.1">All entities that are expected to publish entity statements about other entities MUST expose a Federation API endpoint.  </p>
<p id="rfc.section.7.p.2">The federation API endpoint of an entity can be found in the configuration response as described in <a href="#federation_configuration" class="xref">Section 6</a> or by other means.  </p>
<p id="rfc.section.7.p.3">The Federation API is an HTTPS API that MAY support multiple operations. Fetching entity statements is one of the operations, and the only one that all Federation API endpoints are REQUIRED to support.  All the other operations are OPTIONAL. The list of defined operations MAY be extended in the future.  </p>
<p id="rfc.section.7.p.4">While all operations on the federation API endpoint make use of a GET request, other operations MAY choose to use other HTTP methods. If the <samp>operation</samp> parameter is left out, it is treated as a fetch entity statements request. Unless otherwise mentioned or agreed upon, requests to the federation API do not need to be authenticated.  </p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> Fetching Entity Statements (REQUIRED)</h1>
<p id="rfc.section.7.1.p.1">Fetching entity statements is performed to collect entity statements one by one to gather trust chains.  </p>
<p id="rfc.section.7.1.p.2">To fetch an entity statement, an entity needs to know the identifier of the entity to ask (the issuer), the federation API endpoint of that entity and the identifier of the entity that you want the statement to be about (the subject).  </p>
<h1 id="rfc.section.7.1.1">
<a href="#rfc.section.7.1.1">7.1.1.</a> <a href="#fetch_statement" id="fetch_statement">Fetch Entity Statements Request</a>
</h1>
<p id="rfc.section.7.1.1.p.1">The request MUST be an HTTP request using the GET method and the https scheme to a resolved federation API endpoint with the following query string parameters: </p>
<p></p>

<dl>
<dt>operation</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. If not present, MUST be treated as <samp>fetch</samp>.  </dd>
<dt>iss</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The entity identifier of the issuer from which you want an entity statement issued. Because of the normalization of the URL, multiple issuers MAY resolve to a shared federation API. This parameter makes it explicit exactly which issuer we want entity statements from.  </dd>
<dt>sub</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. The entity identifier of the subject for which you would like an entity statement issued. If this parameter is left out, it is considered to be the same as the issuer and would indicate a request for a self-issued statement.  </dd>
<dt>aud</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. The entity identifier of the requester. If the <samp>aud</samp> parameter is present in the request, the <samp>aud</samp> claim SHOULD be present in the entity statement response and take exactly that value.  </dd>
</dl>

<p> </p>
<p>The following is a non-normative example of an API request for an entity statement: </p>
<pre>
GET /federation_api_endpoint?
iss=https%3A%2F%2Fopenid.sunet.se%2Ffederation HTTP/1.1
Host: openid.sunet.se
</pre>
<h1 id="rfc.section.7.1.2">
<a href="#rfc.section.7.1.2">7.1.2.</a> Fetch Entity Statements Response</h1>
<p id="rfc.section.7.1.2.p.1">A positive response is a signed entity statement where the content type MUST be set to <samp>application/jose</samp>.  If it is a negative response, it will be a JSON object and the content type MUST be set to <samp>application/json</samp>.  See more about error responses in <a href="#error_response" class="xref">Section 7.4</a>.  </p>
<p>The following is a non-normative example of a response, before serialization and adding a signature: </p>
<pre>
200 OK
Last-Modified: Mon, 17 Dec 2018 11:15:56 GMT
Content-Type: application/jose

{
  "iss": "https://openid.sunet.se",
  "sub": "https://openid.sunet.se",
  "iat": 1516239022,
  "exp": 1516298022,
  "metadata": {
    "openid_relying_party": {
      "application_type": "web",
      "redirect_uris": [
        "https://openid.sunet.se/rp/callback"
      ],
      "organization_name": "SUNET",
      "logo_uri": "https://www.sunet.se/sunet/images/32x32.png",
      "grant_types": [
        "authorization_code",
        "implicit"
      ],
      "jwks_uri": "https://openid.sunet.se/rp/jwks.json"
    }
  },
  "jwks": {
    "keys": [
      {
        "alg": "RS256",
        "e": "AQAB",
        "key_ops": [
          "verify"
        ],
        "kid": "key1",
        "kty": "RSA",
        "n": "pnXBOusEANuug6ewezb9J_...",
        "use": "sig"
      }
    ]
  },
  "authority_hints": [
    "https://edugain.org/federation"
  ]
}
</pre>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> Trust Negotiation (OPTIONAL)</h1>
<p id="rfc.section.7.2.p.1">An entity MAY use the trust negotiation operation to fetch resolved metadata about itself as seen/trusted by a remote peer.  The result may, for instance, tell an RP what operations, scopes and claims an OP would allow the RP to use if a specific trust anchor was used.  </p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> Trust Negotiation Request</h1>
<p id="rfc.section.7.2.1.p.1">The request MUST be an HTTP request using the GET method and the https scheme to a resolved federation API endpoint with the following query string parameters: </p>
<p></p>

<dl>
<dt>operation</dt>
<dd style="margin-left: 8">
<br> REQUIRED. MUST be set to <samp>resolve_metadata</samp>.  </dd>
<dt>respondent</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The entity identifier of the entity whose metadata are requested. Because of the normalization of the URL, multiple entity identifiers may resolve to a shared federation API. This parameter makes it explicit exactly which entity is expected.  </dd>
<dt>peer</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The entity identifier of the entity the information is requested for. This MUST be a leaf entity.  </dd>
<dt>type</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The metadata type to resolve.  In this document, we use the metadata types listed in <a href="#metadata" class="xref">Section 4</a>.  </dd>
<dt>anchor</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The trust anchor that the remote peer MUST use when resolving the metadata. The value is an entity identifier.  </dd>
</dl>

<p> </p>
<p>The following is a non-normative example of an API request for trust negotiation: </p>
<pre>
GET /federation_api_endpoint?
operation=resolve_metadata&amp;
respondent=https%3A%2F%2Fopenid.sunet.se%2Ffederation&amp;
type=openid_provider&amp;
anchor=https%3A%2F%2Fswamid.se&amp;
peer=https%3A%2F%2Fidp.umu.se%2Fopenid HTTP/1.1
Host: openid.sunet.se
</pre>
<h1 id="rfc.section.7.2.2">
<a href="#rfc.section.7.2.2">7.2.2.</a> Trust Negotiation Response</h1>
<p id="rfc.section.7.2.2.p.1">The response is a metadata statement that is the result of applying the metadata policies in the trust chain on the entity's metadata.  </p>
<p>The following is a non-normative example of a response: </p>
<pre>
200 OK
Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
Content-Type: application/json

{
  "organization_name": "University of Umea",
  "contacts": [
    "legal@umu.se",
    "technical@umu.se"
  ],
  "logo_uri":
    "https://www.umu.se/SRWStatic/img/umu-logo-left-neg-SE.svg",
  "op_policy_uri":
    "https://www.umu.se/en/about-the-website/legal-information/",
  "authorization_endpoint":
    "https://idp.umu.se/openid/authorization",
  "token_endpoint": "https://idp.umu.se/openid/token",
  "response_types_supported": [
    "code",
    "code id_token",
    "token"
  ],
  "grant_types_supported": [
    "authorization_code",
    "implicit",
    "urn:ietf:params:oauth:grant-type:jwt-bearer"
  ],
  "subject_types_supported": [
    "pairwise"
  ],
  "id_token_signing_alg_values_supported": [
    "RS256"
  ],
  "issuer": "https://idp.umu.se/openid",
  "jwks_uri": "https://idp.umu.se/openid/jwks_uri.json"
}
</pre>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#entity_listings" id="entity_listings">Entity Listings (OPTIONAL)</a>
</h1>
<p id="rfc.section.7.3.p.1">An entity MAY query another entity for a list of all the entities immediately subordinate to that entity and about which that entity is prepared to issue statements about.  (In some cases, this MAY be a very large list.) </p>
<h1 id="rfc.section.7.3.1">
<a href="#rfc.section.7.3.1">7.3.1.</a> Entity Listings Request</h1>
<p id="rfc.section.7.3.1.p.1">The request MUST be an HTTP request using the GET method and the https scheme to a resolved federation API endpoint with the following query string parameters: </p>
<p></p>

<dl>
<dt>operation</dt>
<dd style="margin-left: 8">
<br> REQUIRED. MUST be set to <samp>listing</samp>.  </dd>
<dt>iss</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The entity identifier of the entity from which an entity listing is requested. Because of the normalization of the URL, multiple entity identifiers may resolve to a shared federation API. This parameter makes it explicit exactly which entity is expected.  </dd>
<dt>is_leaf</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. If left out, the result should include both leaf entities and intermediate nodes. If set to <samp>true</samp>, the response SHOULD contain only leaf entities. If set to <samp>false</samp>, the response SHOULD contain only intermediate nodes.  </dd>
</dl>

<p> </p>
<p>The following is a non-normative example of an API request for trust negotiation: </p>
<pre>
GET /federation_api_endpoint?
operation=listing&amp;
iss=https%3A%2F%2Fopenid.sunet.se%2Ffederation HTTP/1.1
Host: openid.sunet.se
</pre>
<h1 id="rfc.section.7.3.2">
<a href="#rfc.section.7.3.2">7.3.2.</a> Entity Listing Response</h1>
<p id="rfc.section.7.3.2.p.1">The response MUST contain an JSON list with the known entity identifiers.  </p>
<p>The following is a non-normative example of a response: </p>
<pre>
200 OK
Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
Content-Type: application/json

[
  "https://ntnu.andreas.labs.uninett.no/",
  "https://blackboard.ntnu.no/openid/callback",
  "https://serviceprovider.andreas.labs.uninett.no/application17"
]
</pre>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#error_response" id="error_response">Generic Error Response</a>
</h1>
<p id="rfc.section.7.4.p.1">If the request was malformed, or some error occurred during processing of the request, the following standardized error format SHOULD be used regardless of the operation specified.  </p>
<p id="rfc.section.7.4.p.2">The HTTP response code MUST be something in 400/500-range, giving an indication of the type of error. The response body MUST be a JSON object containing the claims below and the content type MUST be set to <samp>application/json</samp>.  </p>
<p></p>

<dl>
<dt>operation</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The operation of the request.  </dd>
<dt>error</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The error code.  </dd>
<dt>error_description</dt>
<dd style="margin-left: 8">
<br> REQUIRED. A human-readable short text describing the error.  </dd>
</dl>

<p> </p>
<p>The following is a non-normative example of an error response: </p>
<pre>
400 Bad request
Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
Content-Type: application/json

{
  "operation": "fetch",
  "error": "invalid_request",
  "error_description":
    "Required request parameter [iss] was missing."
}
</pre>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#resolving_trust" id="resolving_trust">Resolving Trust Chain and Metadata</a>
</h1>
<p id="rfc.section.8.p.1">An entity (e.g., the Consumer) that wants to establish trust with a remote peer, MUST have the remote peer's entity identifier and a list of entity identifiers of trust anchors together with the public version of their signing keys. The Consumer will first have to fetch sufficient entity statements to establish at least one chain of trust from the remote peer to one or more of the configured trust anchors.  After that the entity MUST validate the trust chains independently, and -- if there are multiple valid trust chains and if the application demands it -- choose one.  </p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#fetching-es" id="fetching-es">Fetching Entity Statements to Establish a Trust Chain</a>
</h1>
<p id="rfc.section.8.1.p.1">Depending on the circumstances, the Consumer MAY either be handed the remote peer's self-issued entity statement, or it may have to fetch it by itself. If it needs to fetch it, it will use the process described in <a href="#fetch_statement" class="xref">Section 7.1.1</a> with both <samp>iss</samp> and <samp>sub</samp> containing the entity identifier of the remote peer.  </p>
<p id="rfc.section.8.1.p.2">The next step is to iterate through the list of intermediates listed in <samp>authority_hints</samp>, ignoring the authority hints that end in an unknown trust anchor, requesting an entity statement about the remote peer from each of the intermediates.  If the received entity statement contains an authority hint this process is repeated. This time with the <samp>iss</samp> set to the intermediate's entity identifier and the <samp>sub</samp> to be the <samp>iss</samp> of the previous query.  The Consumer SHOULD NOT attempt to fetch entity statements it already has fetched during this process (loop prevention).  </p>
<p id="rfc.section.8.1.p.3">A successful operation will return one or more lists of entity statements. Each of the lists terminating in a self-signed entity statement is issued by a trust anchor.  </p>
<p id="rfc.section.8.1.p.4">If there is no path from the remote peer to at least one of the trusted trust anchors, then the list will be empty and there is no way of establishing trust in the remote peer's information. How the Consumer deals with this is out of scope for this specification.  </p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#trust_chain_validation" id="trust_chain_validation">Validating a Trust Chain</a>
</h1>
<p id="rfc.section.8.2.p.1">As described in <a href="#trust_chain" class="xref">Section 3.2</a>, a trust chain consists of an ordered list of entity statements. So whichever way the Consumer has acquired the set of entity statements, it MUST now verify that it is a proper trust chain using the rules laid out in that section.  </p>
<p id="rfc.section.8.2.p.2">To validate the chain, the following MUST be done: </p>
<p></p>

<ul>
<li>For each entity statement ES[j] j=i,..,0: <ul>
<li>Verify that the statement contains all the required claims.  </li>
<li>Verify that <samp>iat</samp> has a value in the past.  </li>
<li>Verify that <samp>exp</samp> has a value that is in the future.  </li>
</ul>
<p> </p>
</li>
<li>For j=0 verify that <samp>iss</samp> == <samp>sub</samp>.  </li>
<li>For j=0,...,i-1: Verify that ES[j]['iss'] == ES[j+1]['sub'] </li>
<li>For j=0,...,i-1: Verify the signature of ES[j] using a public key carried in ES[j+1]['jwks'].  </li>
<li>For j == 0 verify the signature of ES[0] using a public key carried in ES[0]['jwks'].  </li>
<li>For j == i: verify that a) the issuer matches the configured identifier of a trust anchor and b) its signature is valid with the likewise configured public key of said trust anchor.  </li>
</ul>

<p> </p>
<p id="rfc.section.8.2.p.4">Verifying the signature is a much more expensive operation then verifying the correctness of the statement and the timestamps. An implementer MAY therefor chose to not verify the signature until all the other checks have been done.  </p>
<p id="rfc.section.8.2.p.5">Consumers MAY cache Entity Statements or signature verification results for a given time until they expire <a href="#trust_lifetime" class="xref">Section 8.4</a>.  </p>
<p id="rfc.section.8.2.p.6">Note that the second bullet point means that, at each step in the trust chain resolution, it MUST be verified that the signing JWK is also present in the <samp>jwks</samp> statement claim issued by the superior.  </p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> Choosing One of the Valid Trust Chains</h1>
<p id="rfc.section.8.3.p.1">If multiple valid trust chains are found, the Consumer will need to decide on which one to use.  </p>
<p id="rfc.section.8.3.p.2">One simple rule would be to prefer a shorter chain over a longer one.  </p>
<p id="rfc.section.8.3.p.3">Consumers MAY follow other rules according to local policy.</p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#trust_lifetime" id="trust_lifetime">Calculating the Expiration Time of a Trust Chain</a>
</h1>
<p id="rfc.section.8.4.p.1">Each entity statement in a trust chain is signed and MUST have an expiration time (exp) set. The expiration time of the whole trust chain is set to the minimum value of exp within the chain.  </p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Updating Metadata, Key Rollover, and Revocation</h1>
<p id="rfc.section.9.p.1">This specification allows for a smooth process of updating metadata and public keys.  </p>
<p id="rfc.section.9.p.2">As described above in <a href="#trust_lifetime" class="xref">Section 8.4</a>, each trust chain has an expiration time.  A consumer of metadata using this specification MUST support refreshing a trust chain when it expires.  How often a consumer SHOULD re-evaluate the trust chain depends on how quickly the consumer wants to find out that something has changed in the trust chain.  </p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> Protocol Key Rollover</h1>
<p id="rfc.section.9.1.p.1">If a leaf entity publishes its public keys in the metadata part using <samp>jwks</samp>, setting an expiration time on the self-signed entity statement can be used to control how often the receiving entity is fetching an updated version of the public key.  </p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#key_rollover_anchor" id="key_rollover_anchor">Key Rollover for a Trust Anchor</a>
</h1>
<p id="rfc.section.9.2.p.1">A trust anchor MUST publish a self-signed entity statement about itself. The trust anchor SHOULD set a reasonable expiration time on that statement, such that the consumers will re-fetch the entity statement at reasonable intervals. If the trust anchor wants to roll over its signing keys it would have to: </p>
<p></p>

<ol>
<li>Add the new keys to the <samp>jwks</samp> representing the trust anchors signing keys.  </li>
<li>Keep signing the entity statement using the old keys for a long enough time period to allow all subordinates to have gotten access to the new keys.  </li>
<li>Switch to signing with the new keys.  </li>
<li>After a reasonable time period remove the old keys. What is regarded as a reasonable time is dependent on the security profile and risk assessment of the trust anchor.  </li>
</ol>

<p> </p>
<p id="rfc.section.9.2.p.3">It MUST be taken into consideration that clients MAY have manually configured public keys as part of their configuration.  </p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> Revocation</h1>
<p id="rfc.section.9.3.p.1">Since the consumers are expected to check the trust chain at regular, reasonably frequent times, this specification does not specify a standard revocation process. Specific federations MAY make a different choice and will then have to add such a process.  </p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#client_registration" id="client_registration">OpenID Connect Communication</a>
</h1>
<p id="rfc.section.10.p.1">This section describes how the trust framework in this specification is used to establish trust between an RP and an OP that have no explicit configuration or registration in advance.  </p>
<p id="rfc.section.10.p.2">There are two alternative approaches to establish trust between an RP and an OP, which we call automatic and explicit registration. Members of a federation or a community SHOULD agree upon which one to use. While implementations should support both methods, deployments MAY choose to disable the use of one of them.  </p>
<p id="rfc.section.10.p.3">Independent of whether the RP uses automatic or explicit registration, the way that the RP learns about the OP is the same.  It will use the procedure that is described in <a href="#resolving_trust" class="xref">Section 8</a>.  </p>
<h1 id="rfc.section.10.1">
<a href="#rfc.section.10.1">10.1.</a> <a href="#automatic" id="automatic">Automatic Registration</a>
</h1>
<p id="rfc.section.10.1.p.1">Automatic registration allows an RP to send Authorization Requests to an OP without first registering with the OP. It basically works by the OP using the Client ID in the request to find the RP's metadata using the process outlined in <a href="#resolving_trust" class="xref">Section 8</a> and then verifies that the RP is in control of a private key that is a companion to one of the public keys the RP published through its metadata.  </p>
<p id="rfc.section.10.1.p.2">For automatic registration to work a number of things MUST be valid: </p>

<ul>
<li>The Client ID of the RP MUST be set to be identical to the RP entity identifier.  </li>
<li>Without a registration process, the RP does not have a client secret. Instead, the automatic registration model requires the RP to make use of asymmetric cryptography. Basically, the RP must prove that it has control of the RP's private keys.  </li>
<li>The Client ID MUST be a URL from which the OP can fetch the RP's self-signed entity statement using the process described in <a href="#federation_configuration" class="xref">Section 6</a>.  </li>
<li>The OP MUST publish that it supports a request authentication method using the metadata claim <samp>request_authentication_methods_supported</samp>.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.10.1.1">
<a href="#rfc.section.10.1.1">10.1.1.</a> Authentication Request</h1>
<p id="rfc.section.10.1.1.p.1">The Authentication Request is performed by passing a Request Object by value as described in Section 6.1 in <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a> or using pushed authorization as described in <a href="#PAR" class="xref">Pushed Authorization Requests</a>.  </p>
<h1 id="rfc.section.10.1.1.1">
<a href="#rfc.section.10.1.1.1">10.1.1.1.</a> Using a Request Object</h1>
<p id="rfc.section.10.1.1.1.p.1">In the case where a Request Object is used, the value of the <samp>request</samp> parameter is a JWT whose Claims are the request parameters specified in Section 3.1.2 in <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a>.  The JWT MUST be signed and MAY be encrypted.  The following restrictions apply to the JWT: </p>

<dl>
<dt>aud</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The Audience (aud) MUST be the URL of the Authorization Server's Authorization Endpoint.  </dd>
<dt>iss</dt>
<dd style="margin-left: 8">
<br> REQUIRED. The claim <samp>iss</samp> MUST contain the client identifier.  </dd>
<dt>sub</dt>
<dd style="margin-left: 8">
<br> MUST NOT be present. This together with the value of <samp>aud</samp> SHOULD make reuse of the statement for <samp>private_key_jwt</samp> client authentication not feasible.  </dd>
<dt>jti</dt>
<dd style="margin-left: 8">
<br> REQUIRED. JWT ID. A unique identifier for the JWT, which can be used to prevent reuse of the token. These tokens MUST only be used once, unless conditions for reuse were negotiated between the parties; any such negotiation is beyond the scope of this specification.  </dd>
<dt>exp</dt>
<dd style="margin-left: 8">
<br> REQUIRED. Expiration time on or after which the JWT MUST NOT be accepted for processing.  </dd>
<dt>iat</dt>
<dd style="margin-left: 8">
<br> OPTIONAL. Time at which the JWT was issued.  </dd>
</dl>

<p> </p>
<p>The following is a non-normative example of the Claims in a Request Object before base64url encoding and signing: </p>
<pre>
{
  "aud": "https://op.example.org/authorization",
  "client_id": "https://rp.example.com",
  "exp": 1589699162,
  "iat": 1589699102,
  "iss": "https://rp.example.com",
  "jti": "4d3ec0f81f134ee9a97e0449be6d32be",
  "nonce": "4LX0mFMxdBjkGmtx7a8WIOnB",
  "redirect_uri": "https://rp.example.com/authz_cb",
  "response_type": "code",
  "scope": "openid profile email address phone",
  "state": "YmX8PM9I7WbNoMnnieKKBiptVW0sP2OZ",
  "sub": "https://rp.example.com"
}
</pre>
<p>The following is a non-normative example of an Authorization Request using the request parameter (with line wraps within values for display purposes only): </p>
<pre>
https://server.example.com/authorize?
    redirect_uri=https%3A%2F%2Frp.example.com%2Fauthz_cb
    &amp;scope=openid+profile+email+address+phone
    &amp;response_type=code
    &amp;client_id=https%3A%2F%2Frp.example.com
    &amp;request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImRVTjJhMDF3Umtoa1
      NXcGxRVGh2Y1ZCSU5VSXdUVWRPVUZVMlRtVnJTbWhFUVhnelpYbHB
      UemRRTkEifQ.eyJzdWIiOiAiaHR0cHM6Ly9ycC5leGFtcGxlLmNvb
      SIsICJpc3MiOiAiaHR0cHM6Ly9ycC5leGFtcGxlLmNvbSIsICJpYX
      QiOiAxNTkzNjE1Nzk0LCAiZXhwIjogMTU5MzYxNTg1NCwgImF1ZCI
      6ICJodHRwczovL29wLmV4YW1wbGUub3JnL2F1dGhvcml6YXRpb24i
      LCAianRpIjogIjlhNDY2Njc3ZDZkOTQ5OWZiOTFjNDg4YTY1NzA0N
      TU2In0.mFq0V4KIb6eM-WV5vvQAvSSwoUyi-cy_ASMDgR1-amotjK
      6El0T1WV9-Hdrkgi_zBJtARs6VE380GmwpXXuMF1p6y-IoyIBJUSR
      w9LaeK9oi3d1stTT_J6VL8JwsNuetB6r9YLAQS-1p6mFKsv7TQSjk
      xNHfw0BTxfZftcDnooCqusC17xrz11qEY1CCtjDbbxYM1cYfzGFwS
      I0UZneQUZqa2ChOqWTguumG7XonB5NFZWieAtvyyPZaSI7AW5wCs2
      sH6kjMxOHEAIvxygZZwKpTiToccYtU7t0n2xKRr-oYDQaFjuRIemE
      xsuzVl6pbvCVYqyjxFscS9NgDB-hAAQ
</pre>
<h1 id="rfc.section.10.1.1.1.1">
<a href="#rfc.section.10.1.1.1.1">10.1.1.1.1.</a> Processing the Authentication Request</h1>
<p id="rfc.section.10.1.1.1.1.p.1">When the OP receives an incoming Authentication Request, the OP supports OpenID Connect Federation, the incoming Client ID is a valid URL, and the OP does not have the Client ID registered as a known client, then the OP SHOULD try to resolve and fetch trust chains starting with the RP's entity statement as described in <a href="#fetching-es" class="xref">Section 8.1</a>.  </p>
<p id="rfc.section.10.1.1.1.1.p.2">The OP MUST then validate the possible trust chains, as described in <a href="#trust_chain_validation" class="xref">Section 8.2</a>, and resolve the RP metadata with type <samp>openid_relying_party</samp>.  </p>
<p id="rfc.section.10.1.1.1.1.p.3">The OP SHOULD furthermore consider the resolved metadata of the RP, and verify that it complies with the client metadata specification in <a href="#OpenID.Registration" class="xref">OpenID Connect Dynamic Client Registration 1.0</a>.  </p>
<p id="rfc.section.10.1.1.1.1.p.4">Once the OP has the RP's metadata, it can verify that the client was actually the one sending the Authorization Request by verifying the signature of the Request Object using the key material the client published through its metadata.  </p>
<h1 id="rfc.section.10.1.1.2">
<a href="#rfc.section.10.1.1.2">10.1.1.2.</a> Using Pushed Authorization</h1>
<p><a href="#PAR" class="xref">Pushed Authorization</a> provides an interoperable way to push the payload of a Request Object directly to the AS in exchange for a <samp>request_uri</samp>.  </p>
<p id="rfc.section.10.1.1.2.p.2">When it comes to request authentication, the applicable methods are three: </p>

<ul>
<li>Using a JWT for Client authentication as described for <samp>private_key_jwt</samp> in Section 9 of <a href="#OpenID.Core" class="xref">OpenID Connect Core 1.0</a>.  </li>
<li>mTLS as described in Section 2.2 of <a href="#RFC8705" class="xref">[RFC8705]</a> based on self-signed certificates.  In this case the self-signed certificate MUST be present as the value of an <samp>x5c</samp> claim for one key in the JWK Set describing the RP's keys.  </li>
<li>mTLS as described in Section 2.1 of <a href="#RFC8705" class="xref">[RFC8705]</a> based on public key infrastructure (PKI).  </li>
</ul>

<p> Note that if mTLS is used, TLS client authentication MUST be configured and, in case of self-signed certificates, the server must omit trust chain validation (optional_no_ca).  </p>
<p id="rfc.section.10.1.1.2.p.3">Using the example above, a request could look like this:</p>
<pre>
POST /par HTTP/1.1
Host: op.example.org
Content-Type: application/x-www-form-urlencoded

redirect_uri=https%3A%2F%2Frp.example.com%2Fauthz_cb
&amp;scope=openid+profile+email+address+phone
&amp;response_type=code
&amp;nonce=4LX0mFMxdBjkGmtx7a8WIOnB
&amp;state=YmX8PM9I7WbNoMnnieKKBiptVW0sP2OZ
&amp;client_id=https%3A%2F%2Frp.example.com
&amp;client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3A
  client-assertion-type%3Ajwt-bearer
&amp;client_assertion=eyJhbGciOiJSUzI1NiIsImtpZCI6ImRVTjJ
  hMDF3Umtoa1NXcGxRVGh2Y1ZCSU5VSXdUVWRPVUZVMlRtVnJTbW
  hFUVhnelpYbHBUemRRTkEifQ.eyJzdWIiOiAiaHR0cHM6Ly9ycC
  5leGFtcGxlLmNvbSIsICJpc3MiOiAiaHR0cHM6Ly9ycC5leGFtc
  GxlLmNvbSIsICJpYXQiOiAxNTg5NzA0NzAxLCAiZXhwIjogMTU4
  OTcwNDc2MSwgImF1ZCI6ICJodHRwczovL29wLmV4YW1wbGUub3J
  nL2F1dGhvcml6YXRpb24iLCAianRpIjogIjM5ZDVhZTU1MmQ5Yz
  Q4ZjBiOTEyZGM1NTY4ZWQ1MGQ2In0.oUt9Knx_lxb4V2S0tyNFH
  CNZeP7sImBy5XDsFxv1cUpGkAojNXSy2dnU5HEzscMgNW4wguz6
  KDkC01aq5OfN04SuVItS66bsx0h4Gs7grKAp_51bClzreBVzU4g
  _-dFTgF15T9VLIgM_juFNPA_g4Lx7Eb5r37rWTUrzXdmfxeou0X
  FC2p9BIqItU3m9gmH0ojdBCUX5Up0iDsys6_npYomqitAcvaBRD
  PiuUBa5Iar9HVR-H7FMAr7aq7s-dH5gx2CHIfM3-qlc2-_Apsy0
  BrQl6VePR6j-3q6JCWvNw7l4_F2UpHeanHb31fLKQbK-1yoXDNz
  DwA7B0ZqmuSmMFQ</pre>
<h1 id="rfc.section.10.1.1.2.1">
<a href="#rfc.section.10.1.1.2.1">10.1.1.2.1.</a> Processing the Authentication Request</h1>
<p id="rfc.section.10.1.1.2.1.p.1">There are three different paths the OP MUST follow when processing the Authentication Request depending on which request authentication method that was used. It all starts the same though.  When the OP receives an incoming Authentication Request, the OP supports OpenID Connect Federation, the incoming Client ID is a valid URL, the OP does not have the Client ID registered as a known client and the OP supports the request authentication method used then the OP SHOULD try to resolve and fetch trust chains starting with the RP's entity statement as described in <a href="#fetching-es" class="xref">Section 8.1</a>.  </p>
<p id="rfc.section.10.1.1.2.1.p.2">The OP SHOULD validate the possible trust chains, as described in <a href="#trust_chain_validation" class="xref">Section 8.2</a>, and resolve the RP metadata with type <samp>openid_relying_party</samp>.  </p>
<p id="rfc.section.10.1.1.2.1.p.3">The OP SHOULD consider the resolved metadata of the RP, and verify that it complies with the client metadata specification in <a href="#OpenID.Registration" class="xref">OpenID Connect Dynamic Client Registration 1.0</a>.  </p>
<p id="rfc.section.10.1.1.2.1.p.4">Once the OP has the RP's metadata, it can verify the client.  This is where it diverges depending on which client authentication method was used.  </p>

<dl>
<dt>private_key_jwt</dt>
<dd style="margin-left: 8">
<br> If this method is used, then the OP will try to verify the signature of the signed JWT using the key material published by the RP in its metadata. If the authentication is successful, then the registration is regarded as correct.  </dd>
<dt>tls_client_auth</dt>
<dd style="margin-left: 8">
<br> If mTLS is used and the certificate used was not self-signed, then the Subject Alternative Name of the certificate MUST match the entity identifier of the RP.  </dd>
<dt>self_signed_tls_client_auth</dt>
<dd style="margin-left: 8">
<br> If mTLS is used and the certificate used is a self-signed certificate, then the certificate MUST be present as the value of an <samp>x5c</samp> claim for one key in the JWK Set describing the RP's keys.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.10.1.2">
<a href="#rfc.section.10.1.2">10.1.2.</a> Authentication Error Response</h1>
<p id="rfc.section.10.1.2.p.1">If the OP fails to establish trust with the RP, it SHOULD use an appropriate error code, and an <samp>error_description</samp> that aids the RP to understand what is wrong.  </p>
<p id="rfc.section.10.1.2.p.2">In addition to the error codes defined in Section 3.1.2.6 of OpenID Connect Core, this specification also defines the following error codes: </p>
<p></p>

<dl>
<dt>missing_trust_anchor</dt>
<dd style="margin-left: 8">
<br> No trusted trust anchor could be found.  </dd>
<dt>validation_failed</dt>
<dd style="margin-left: 8">
<br> Trust chain validation failed.  </dd>
</dl>

<p> </p>
<p>The following is a non-normative example error response: </p>
<pre>
HTTP/1.1 302 Found
  Location: https://client.example.org/cb?
    error=missing_trust_anchor
    &amp;error_description=
      Could%20not%20find%20a%20trusted%20anchor
    &amp;state=af0ifjsldkj
</pre>
<h1 id="rfc.section.10.2">
<a href="#rfc.section.10.2">10.2.</a> <a href="#explicit" id="explicit">Explicit Registration</a>
</h1>
<p id="rfc.section.10.2.p.1">This method involves performing an explicit registration of a new client the first time an RP interacts with an OP using something that basically follows the steps in <a href="#OpenID.Registration" class="xref">OpenID Connect Dynamic Client Registration 1.0</a> but where the client registration request is a signed entity statement.  </p>
<h1 id="rfc.section.10.2.1">
<a href="#rfc.section.10.2.1">10.2.1.</a> <a href="#Clireg" id="Clireg">Client Registration</a>
</h1>
<h1 id="rfc.section.10.2.1.1">
<a href="#rfc.section.10.2.1.1">10.2.1.1.</a> <a href="#Cliregreq" id="Cliregreq">Client Registration Request</a>
</h1>
<p id="rfc.section.10.2.1.1.p.1">The OP MUST support OpenID Dynamic Client Registration as extended by this specification.  This is signaled by having the claim <samp>federation_registration_endpoint</samp> in the OP's metadata.  </p>
<p id="rfc.section.10.2.1.1.p.2">Given that the OP supports explicit registration, the RP progresses as follows: </p>
<p></p>

<ol>
<li>Once it has the list of acceptable trust chains for the OP, it MUST choose the subset it wants to progress with. The subset can be as small as one trust chain, but it can also contain more than one.  </li>
<li>Based on the trust anchors referenced in the subset of trust chains, the RP will choose a set of <samp>authority_hints</samp> from its own set that terminate in those trust anchors.  </li>
<li>The RP will now construct a self-signed entity statement where the metadata statement chosen is influenced by the OPs metadata and the <samp>authority_hints</samp> included are picked by the process described above.  Note that the <samp>aud</samp> claim in the entity statement is REQUIRED in this case and MUST be set to the OP issuer identifier.  </li>
<li>The entity statement is sent, using POST, to the <samp>federation_registration_endpoint</samp> defined in this document. The content type MUST be set to <samp>application/jose</samp>.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.10.2.1.2">
<a href="#rfc.section.10.2.1.2">10.2.1.2.</a> <a href="#cliregresp" id="cliregresp">Client Registration Response</a>
</h1>
<h1 id="rfc.section.10.2.1.2.1">
<a href="#rfc.section.10.2.1.2.1">10.2.1.2.1.</a> OP Constructing the Response</h1>
<p id="rfc.section.10.2.1.2.1.p.1">The trust chains MUST be constructed using the received entity statement.  </p>
<p></p>

<ol>
<li>After the OP receives the request, it collects and evaluates the trust chains starting with the <samp>authority_hints</samp> in the registration request.  After it has verified at least one trust chain it MUST verify that the signature on the received registration request is correct.  </li>
<li>If it finds more than one acceptable trust chain, it MUST choose one trust anchor from those chains as the one it will proceed with.  </li>
<li>At this point, if there already exists a client registration under the same entity identifier then that registration MUST be regarded as invalid.  Note that key material from the previous registration SHOULD be kept to enable verifying signatures or decrypting archived data.  </li>
<li>The OP will now construct a metadata policy that, if applied to the RP's metadata statement, will result in metadata that the OP finds acceptable.  Note that the Client ID the OP chooses does not have to be the same as the entity identifier of the RP.  To the entity statement it will add a <samp>trust_anchor_id</samp> claim, containing the trust anchor chosen above.  </li>
<li>It will sign and return the registration response (a signed entity statement) to the RP.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.10.2.1.2.2">
<a href="#rfc.section.10.2.1.2.2">10.2.1.2.2.</a> RP Parsing the Response</h1>
<p></p>

<ol>
<li>The RP verifies the correctness of the received entity statement, making sure that the trust chains starting at the <samp>authority_hints</samp> terminate in trust anchors that were referenced in the entity statement it sent to the OP.  </li>
<li>The RP MUST NOT apply metadata policies from the trust chains that the OP provides because those are not valid for the RP's metadata.  The RP MUST apply policies to the metadata using one of its own trust chains that ends in the trust anchor that the OP chose.  Once it has applied those policies, it can then apply the policy returned from the OP.  When it has applied all the metadata policies to its metadata statement, it then stores the result and can continue communicating with the OP using the agreed-upon metadata.  </li>
<li>At this point the RP also knows which trust chain it should use when evaluating the OP's metadata. It can therefore apply the metadata policies on the OP's metadata using the relevant trust chain and store the result as the OPs metadata.  </li>
<li>If the RP does not accept the received entity statement for some reason, then it has the choice to restart the registration process or to give up.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.10.2.2">
<a href="#rfc.section.10.2.2">10.2.2.</a> After Client Registration</h1>
<p id="rfc.section.10.2.2.p.1">A client registration using this specification is not expected to be valid forever. The entity statements exchanged all have expiration times, which means that the registration will eventually time out. An OP can also, for administrative reasons, decide that a client registration is not valid anymore. An example of this could be that the OP leaves the federation in use.  </p>
<h1 id="rfc.section.10.2.2.1">
<a href="#rfc.section.10.2.2.1">10.2.2.1.</a> What the RP MUST Do</h1>
<p id="rfc.section.10.2.2.1.p.1">At regular intervals, the RP MUST: </p>
<p></p>

<ol>
<li>Starting with the OP's entity statement, resolve and verify the trust chains it chooses to use when constructing the registration request. If those trust chains do not exist anymore or do not verify, then the registration SHOULD be regarded as invalid and a new registration process SHOULD be started.  </li>
<li>If the OP's entity statement was properly formed the RP must now verify that the entity statement it received about itself from the OP is still valid.  Again, if that is not the case the registration SHOULD be regarded as invalid and a new registration process SHOULD be started.  </li>
</ol>

<p> </p>
<p id="rfc.section.10.2.2.1.p.3">What is regarded as reasonable intervals will depend on federation policies and risk assessment by the maintainer of the RP.  </p>
<h1 id="rfc.section.10.2.2.2">
<a href="#rfc.section.10.2.2.2">10.2.2.2.</a> What the OP MUST Do</h1>
<p id="rfc.section.10.2.2.2.p.1">At regular intervals, the OP MUST: </p>
<p></p>

<ol>
<li>If the signature on the registration request has expired, it MUST mark the registration as invalid and demand that the RP MUST re-register. Else </li>
<li>starting with the RP's client registration request, the OP MUST verify that there still is a valid trust chain terminating in the trust anchor the OP chose during the registration process.  </li>
</ol>

<p> </p>
<h1 id="rfc.section.10.2.3">
<a href="#rfc.section.10.2.3">10.2.3.</a> Expiration Times</h1>
<p id="rfc.section.10.2.3.p.1">An OP MUST NOT assign an expiration time to an RP's registration that is later than the trust chain's expiration time.  </p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">TBD Register <samp>federation_types_supported</samp> for OP metadata with initial values <samp>automatic</samp> and <samp>explicit</samp>.  </p>
<p id="rfc.section.11.p.2">TBD Register <samp>federation_type</samp> for RP registration metadata.  </p>
<p id="rfc.section.11.p.3">TBD Register <samp>federation_registration_endpoint</samp> for the OP metadata.  </p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.12.p.1">Some of the interfaces defined in this specification could be used for Denial of Service attacks (DOS), most notably, Entity Listings (<a href="#entity_listings" class="xref">Section 7.3</a>) and automatic client registration (<a href="#automatic" class="xref">Section 10.1</a>).  If you plan to provide these interfaces as a service, you should consider applying normal defense methods, such as those described in <a href="#RFC4732" class="xref">[RFC4732]</a>.  </p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="OpenID.Core">[OpenID.Core]</b></td>
<td class="top">
<a title="Nomura Research Institute, Ltd.">Sakimura, N.</a>, <a title="Ping Identity">Bradley, J.</a>, <a title="Microsoft">Jones, M.</a>, <a title="Google">de Medeiros, B.</a> and <a title="Salesforce">C. Mortimore</a>, "<a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Discovery 1.0</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="OpenID.Discovery">[OpenID.Discovery]</b></td>
<td class="top">
<a title="Nomura Research Institute, Ltd.">Sakimura, N.</a>, <a title="Ping Identity">Bradley, J.</a>, <a title="Microsoft">Jones, M.</a> and <a title="Illumila">E. Jay</a>, "<a href="http://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect Discovery 1.0</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="OpenID.Registration">[OpenID.Registration]</b></td>
<td class="top">
<a title="Nomura Research Institute, Ltd.">Sakimura, N.</a>, <a title="Ping Identity">Bradley, J.</a> and <a title="Microsoft">M. Jones</a>, "<a href="http://openid.net/specs/openid-connect-registration-1_0.html">OpenID Connect Dynamic Client Registration 1.0</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="PAR">[PAR]</b></td>
<td class="top">
<a title="yes.com">Lodderstedt, T.</a>, <a title="Nomura Research Institute, Ltd.">Sakimura, N.</a>, <a title="Ping Identity">Campbell, B.</a>, <a title="Moneyhub Financial Technology">Tonge, D.</a> and <a title="Auth0">F. Skokan</a>, "<a href="https://tools.ietf.org/id/draft-ietf-oauth-par-04.html">OAuth 2.0 Pushed Authorization Requests</a>"</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3339">[RFC3339]</b></td>
<td class="top">
<a>Klyne, G.</a> and <a>C. Newman</a>, "<a href="https://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, DOI 10.17487/RFC3339, July 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4732">[RFC4732]</b></td>
<td class="top">
<a>Handley, M.</a>, <a>Rescorla, E.</a> and <a>IAB</a>, "<a href="https://tools.ietf.org/html/rfc4732">Internet Denial-of-Service Considerations</a>", RFC 4732, DOI 10.17487/RFC4732, December 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7515">[RFC7515]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, DOI 10.17487/RFC7515, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7517">[RFC7517]</b></td>
<td class="top">
<a>Jones, M.</a>, "<a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a>", RFC 7517, DOI 10.17487/RFC7517, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7519">[RFC7519]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7519">JSON Web Token (JWT)</a>", RFC 7519, DOI 10.17487/RFC7519, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7591">[RFC7591]</b></td>
<td class="top">
<a>Richer, J.</a>, <a>Jones, M.</a>, <a>Bradley, J.</a>, <a>Machulak, M.</a> and <a>P. Hunt</a>, "<a href="https://tools.ietf.org/html/rfc7591">OAuth 2.0 Dynamic Client Registration Protocol</a>", RFC 7591, DOI 10.17487/RFC7591, July 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8414">[RFC8414]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Sakimura, N.</a> and <a>J. Bradley</a>, "<a href="https://tools.ietf.org/html/rfc8414">OAuth 2.0 Authorization Server Metadata</a>", RFC 8414, DOI 10.17487/RFC8414, June 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8615">[RFC8615]</b></td>
<td class="top">
<a>Nottingham, M.</a>, "<a href="https://tools.ietf.org/html/rfc8615">Well-Known Uniform Resource Identifiers (URIs)</a>", RFC 8615, DOI 10.17487/RFC8615, May 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8705">[RFC8705]</b></td>
<td class="top">
<a>Campbell, B.</a>, <a>Bradley, J.</a>, <a>Sakimura, N.</a> and <a>T. Lodderstedt</a>, "<a href="https://tools.ietf.org/html/rfc8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</a>", RFC 8705, DOI 10.17487/RFC8705, February 2020.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody><tr>
<td class="reference"><b id="RFC8446">[RFC8446]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr></tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> Provider Information Discovery and Client Registration in a Federation</h1>
<p id="rfc.section.A.p.1">Let us assume the following: The project LIGO would like to offer access to its wiki to all OPs in EduGAIN. LIGO is registered to the InCommon federation.  </p>
<p>The players </p>
<pre>
                       EduGAIN
                          |
       +------------------+------------------+
       |                                     |
    SWAMID                               InCommon
       |                                     |
     umu.se                                  |
       |                                     |
   op.umu.se                           wiki.ligo.org
</pre>
<p id="rfc.section.A.p.2">Both SWAMID and InCommon are identity federations in their own right.  They also have in common that they both are members of the EduGAIN federation.  </p>
<p id="rfc.section.A.p.3">SWAMID and InCommon are different in how they register entities.  SWAMID registers organizations and lets the organizations register entities that belong to the organization, while InCommon registers all entities directly and not beneath any organization entity.  Hence the differences in depth in the federations.  </p>
<p id="rfc.section.A.p.4">Let us assume a researcher from Ume&#229; University would like to login at the LIGO Wiki. At the Wiki, the researcher will use some kind of discovery service to find the home identity provider (op.umu.se) </p>
<p id="rfc.section.A.p.5">Once the RP-part of the Wiki knows which OP it SHOULD talk to it has to find out a couple of things about the OP. All if those things can be found in the metadata. But finding the metadata is not enough; the RP also has to trust the metadata.  </p>
<p id="rfc.section.A.p.6">Let us make a detour and start with what it takes to build a federation.  </p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#federation_intro" id="federation_intro">Setting Up a Federation</a>
</h1>
<p id="rfc.section.A.1.p.1">These are the steps you have to go through to set up your own federation.  What you minimally have to do is: </p>

<ul>
<li>Generate a signing key. This must be a public/private key pair.  </li>
<li>Set up a signing service that can sign JWTs/entity statements using the federation operator's signing key.  </li>
<li>Set up web services that can publish signed entity statements.  You need at least two: one for the URL corresponding to the federation's entity ID returning self-signed entity statements and the other one providing the fetch entity statement request API, as described in <a href="#fetch_statement" class="xref">Section 7.1.1</a>.  </li>
</ul>

<p> </p>
<p id="rfc.section.A.1.p.2">Once you have this, you can start adding entities to your federation.  Adding an entity comes down to: </p>

<ul>
<li>Providing the entity with the federation's entity ID and the public part of the key pairs used by the federation operator for signing entity statements.  </li>
<li>Getting the entity's entity ID and the JWKS that the entity plans to publish in its self-signed entity statement.  </li>
</ul>

<p> </p>
<p id="rfc.section.A.1.p.3">Now before the federation operator starts adding entities, there have to be policies in place on who can be part of the federation and the layout of the federation. Is it supposed to be a one-layer federation like Internet2, a two-layer one like the SWAMID federation, or a multi-layer federation? The federation may also want to think about implementing other policies using the federation policy framework, as described in <a href="#federation_policy" class="xref">Section 5</a>.  </p>
<p id="rfc.section.A.1.p.4">With the federation in place, things can start happening.  </p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#op_discovery" id="op_discovery">The LIGO Wiki Discovers the OP's Metadata</a>
</h1>
<p id="rfc.section.A.2.p.1">Metadata discovery is a sequence of steps that starts with the RP fetching the self-signed entity statement of the leaf (in this case https://op.umu.se) using the process defined in <a href="#federation_configuration" class="xref">Section 6</a>.  What follows thereafter is this sequence of steps: </p>

<ol>
<li>Pick out the immediate superior entities using the authority hints </li>
<li>Fetch the configuration for each such entity. This uses the process defined in <a href="#federation_configuration" class="xref">Section 6</a> </li>
<li>Using the federation API endpoint of the superiors do a fetch request <a href="#fetch_statement" class="xref">Section 7.1.1</a> on the endpoint asking for information about the subordinate entity.  </li>
</ol>

<p> </p>
<p id="rfc.section.A.2.p.2">How many times this has to be repeated depends on the depth of the federation. What follows below is the result of each step the RP has to take to find the OP's metadata using the federation setup described above.  </p>
<p id="rfc.section.A.2.p.3">When building the trust chain, the entity statements issued by a superior about its subordinate are used together with the self-signed entity statement issued by the leaf.  </p>
<p id="rfc.section.A.2.p.4">The self-signed entity statement concerning intermediates are not part of the trust chain.  </p>
<h1 id="rfc.appendix.A.2.1">
<a href="#rfc.appendix.A.2.1">A.2.1.</a> Configuration Information for op.umu.se</h1>
<p id="rfc.section.A.2.1.p.1">The LIGO WIKI RP fetches the self-signed entity statement from the OP (op.umu.se) using the process defined in <a href="#federation_configuration" class="xref">Section 6</a>.  </p>
<p>The result is this entity statement.</p>
<pre>
{
  "authority_hints": [
    "https://umu.se"
  ],
  "exp": 1568397247,
  "iat": 1568310847,
  "iss": "https://op.umu.se",
  "jwks": {
    "keys": [
      {
        "e": "AQAB",
        "kid": "dEEtRjlzY3djcENuT01wOGxrZlkxb3RIQVJlMTY0...",
        "kty": "RSA",
        "n": "x97YKqc9Cs-DNtFrQ7_vhXoH9bwkDWW6En2jJ044yH..."
      }
    ]
  },
  "metadata": {
    "openid_provider": {
      "issuer": "https://op.umu.se/openid",
      "jwks_uri": "https://op.umu.se/openid/jwks_uri.json",
      "authorization_endpoint":
        "https://op.umu.se/openid/authorization",
      "client_registration_type": [
        "automatic",
        "explicit"
      ],
      "grant_types_supported": [
        "authorization_code",
        "implicit",
        "urn:ietf:params:oauth:grant-type:jwt-bearer"
      ],
      "id_token_signing_alg_values_supported": [
        "ES256", "RS256"
      ],
      "logo_uri":
        "https://www.umu.se/img/umu-logo-left-neg-SE.svg",
      "op_policy_uri":
        "https://www.umu.se/en/website/legal-information/",
      "response_types_supported": [
        "code",
        "code id_token",
        "token"
      ],
      "subject_types_supported": [
        "pairwise",
        "public"
      ],
      "token_endpoint": "https://op.umu.se/openid/token",
      "federation_registration_endpoint":
        "https://op.umu.se/openid/fedreg",
      "token_endpoint_auth_methods_supported": [
        "client_secret_post",
        "client_secret_basic",
        "client_secret_jwt",
        "private_key_jwt"
      ]
    }
  },
  "sub": "https://op.umu.se"
}
</pre>
<p id="rfc.section.A.2.1.p.2">The <samp>authority_hints</samp> points to the intermediate https://umu.se. So that is the next step.  </p>
<p id="rfc.section.A.2.1.p.3">This entity statement is the first link in the trust chain.  </p>
<h1 id="rfc.appendix.A.2.2">
<a href="#rfc.appendix.A.2.2">A.2.2.</a> Configuration Information for 'https://umu.se'</h1>
<p id="rfc.section.A.2.2.p.1">The LIGO RP fetches the self-signed entity statement from "https://umu.se" using the process defined in <a href="#federation_configuration" class="xref">Section 6</a>.  </p>
<p id="rfc.section.A.2.2.p.2">The request will look like this:</p>
<pre>
GET /.well-known/openid-federation HTTP/1.1
Host: umu.se
            </pre>
<p id="rfc.section.A.2.2.p.3">And the GET will return:</p>
<pre>
{
  "authority_hints": [
    "https://swamid.se"
  ],
  "exp": 1568397247,
  "iat": 1568310847,
  "iss": "https://umu.se",
  "jwks": {
    "keys": [
      {
        "e": "AQAB",
        "kid": "endwNUZrNTJsX2NyQlp4bjhVcTFTTVltR2gxV2RV...",
        "kty": "RSA",
        "n": "vXdXzZwQo0hxRSmZEcDIsnpg-CMEkor50SOG-1XUlM..."
      }
    ]
  },
  "metadata": {
    "federation_entity": {
      "contacts": "ops@umu.se",
      "federation_api_endpoint": "https://umu.se/oidc/fedapi",
      "homepage_uri": "https://www.umu.se",
      "name": "UmU"
    }
  },
  "sub": "https://umu.se"
}
</pre>
<p id="rfc.section.A.2.2.p.4">The only piece of information that is used from this entity statement is the <samp>federation_api_endpoint</samp>, which is used in the next step.  </p>
<h1 id="rfc.appendix.A.2.3">
<a href="#rfc.appendix.A.2.3">A.2.3.</a> Entity Statement Published by 'https://umu.se' about 'https://op.umu.se'</h1>
<p id="rfc.section.A.2.3.p.1">The RP uses the federation API and the "fetch" command as defined in <a href="#fetch_statement" class="xref">Section 7.1.1</a> to fetch information about "https://op.umu.se" from the API endpoint published in https://umu.se's configuration.  </p>
<p id="rfc.section.A.2.3.p.2">The request will look like this:</p>
<pre>
GET /oidc/fedapi?sub=https%3A%2F%2Fop.umu.se&amp;
iss=https%3A%2F%2Fumu.se HTTP/1.1
Host: umu.se
            </pre>
<p id="rfc.section.A.2.3.p.3">and the result is this:</p>
<pre>
{
  "authority_hints": [
    "https://swamid.se"
  ],
  "exp": 1568397247,
  "iat": 1568310847,
  "iss": "https://umu.se",
  "jwks": {
    "keys": [
      {
        "e": "AQAB",
        "kid": "dEEtRjlzY3djcENuT01wOGxrZlkxb3RIQVJlMTY0...",
        "kty": "RSA",
        "n": "x97YKqc9Cs-DNtFrQ7_vhXoH9bwkDWW6En2jJ044yH..."
      }
    ]
  },
  "metadata_policy": {
    "openid_provider": {
      "contacts": {
        "add": [
          "ops@swamid.se"
        ]
      },
      "organization_name": {
        "value": "University of Ume\u00e5"
      },
      "subject_types_supported": {
        "value": [
          "pairwise"
        ]
      },
      "token_endpoint_auth_methods_supported": {
        "default": [
          "private_key_jwt"
        ],
        "subset_of": [
          "private_key_jwt",
          "client_secret_jwt"
        ],
        "superset_of": [
          "private_key_jwt"
        ]
      }
    }
  },
  "sub": "https://op.umu.se"
}
</pre>
<p id="rfc.section.A.2.3.p.4">This is the second link in the trust chain.  </p>
<p id="rfc.section.A.2.3.p.5">Notable here is that this path leads to two trust anchors using the same next step ("https://swamid.se").  </p>
<h1 id="rfc.appendix.A.2.4">
<a href="#rfc.appendix.A.2.4">A.2.4.</a> Configuration Information for 'https://swamid.se'</h1>
<p id="rfc.section.A.2.4.p.1">The LIGO Wiki RP fetches the self-signed entity statement from "https://swamid.se" using the process defined in <a href="#federation_configuration" class="xref">Section 6</a>.  </p>
<p id="rfc.section.A.2.4.p.2">The request will look like this:</p>
<pre>
GET /.well-known/openid-federation HTTP/1.1
Host: swamid.se
            </pre>
<p id="rfc.section.A.2.4.p.3">And the GET will return:</p>
<pre>
{
  "authority_hints": [
    "https://edugain.geant.org"
  ],
  "exp": 1568397247,
  "iat": 1568310847,
  "iss": "https://swamid.se",
  "jwks": {
    "keys": [
      {
        "e": "AQAB",
        "kid": "N1pQTzFxUXZ1RXVsUkVuMG5uMnVDSURGRVdhUzdO...",
        "kty": "RSA",
        "n": "3EQc6cR_GSBq9km9-WCHY_lWJZWkcn0M05TGtH6D9S..."
      }
    ]
  },
  "metadata": {
    "federation_entity": {
      "contacts": "ops@swamid.se",
      "federation_api_endpoint":
        "https://swamid.sunet.se/fedapi",
      "homepage_uri": "https://www.sunet.se/swamid/",
      "name": "SWAMID"
    }
  },
  "sub": "https://swamid.se"
}
</pre>
<p id="rfc.section.A.2.4.p.4">The only piece of information that is used from this entity statement is the <samp>federation_api_endpoint</samp>, which is used in the next step.  </p>
<h1 id="rfc.appendix.A.2.5">
<a href="#rfc.appendix.A.2.5">A.2.5.</a> Entity Statement Published by 'https://swamid.se' about 'https://umu.se'</h1>
<p id="rfc.section.A.2.5.p.1">The LIGO Wiki RP uses the federation API and the "fetch" command as defined in <a href="#fetch_statement" class="xref">Section 7.1.1</a> to fetch information about "https://umu.se" from the API endpoint published in https://swamid.se's configuration.  </p>
<p id="rfc.section.A.2.5.p.2">The request will look like this:</p>
<pre>
GET /fedapi?sub=https%3A%2F%2Fumu.se&amp;
iss=https%3A%2F%2Fswamid.se HTTP/1.1
Host: swamid.se
            </pre>
<p id="rfc.section.A.2.5.p.3">and the result is this:</p>
<pre>
{
  "authority_hints": [
    "https://edugain.geant.org"
  ],
  "exp": 1568397247,
  "iat": 1568310847,
  "iss": "https://swamid.se",
  "jwks": {
    "keys": [
      {
        "e": "AQAB",
        "kid": "endwNUZrNTJsX2NyQlp4bjhVcTFTTVltR2gxV2RV...",
        "kty": "RSA",
        "n": "vXdXzZwQo0hxRSmZEcDIsnpg-CMEkor50SOG-1XUlM..."
      }
    ]
  },
  "metadata_policy": {
    "openid_provider": {
      "id_token_signing_alg_values_supported": {
        "subset_of": [
          "RS256",
          "ES256",
          "ES384",
          "ES512"
        ]
      },
      "token_endpoint_auth_methods_supported": {
        "subset_of": [
          "client_secret_jwt",
          "private_key_jwt"
        ]
      },
      "userinfo_signing_alg_values_supported": {
        "subset_of": [
          "ES256",
          "ES384",
          "ES512"
        ]
      }
    }
  },
  "sub": "https://umu.se"
}
</pre>
<p id="rfc.section.A.2.5.p.4">This is the third link in the trust chain.  </p>
<p id="rfc.section.A.2.5.p.5">If we assume that the issuer of this entity statement is not in the list of trust anchors the LIGO Wiki RP has access to we have to go one step further.  </p>
<h1 id="rfc.appendix.A.2.6">
<a href="#rfc.appendix.A.2.6">A.2.6.</a> Configuration Information for 'https://edugain.geant.org'</h1>
<p id="rfc.section.A.2.6.p.1">RP fetches the self-signed entity statement from "https://edugain.geant.org" using the process defined in <a href="#federation_configuration" class="xref">Section 6</a>.  </p>
<p id="rfc.section.A.2.6.p.2">The request will look like this:</p>
<pre>
GET /.well-known/openid-federation HTTP/1.1
Host: edugain.geant.org
            </pre>
<p id="rfc.section.A.2.6.p.3">And the GET will return:</p>
<pre>
{
  "exp": 1568397247,
  "iat": 1568310847,
  "iss": "https://edugain.geant.org",
  "jwks": {
    "keys": [
      {
        "e": "AQAB",
        "kid": "Sl9DcjFxR3hrRGdabUNIR21KT3dvdWMyc2VUM2Fr...",
        "kty": "RSA",
        "n": "xKlwocDXUw-mrvDSO4oRrTRrVuTwotoBFpozvlq-1q..."
      }
    ]
  },
  "metadata": {
    "federation_entity": {
      "federation_api_endpoint": "https://geant.org/edugain/api"
    }
  },
  "sub": "https://edugain.geant.org"
}

</pre>
<p id="rfc.section.A.2.6.p.4">Again, the only thing we need is the <samp>federation_api_endpoint</samp>.  As described in <a href="#key_rollover_anchor" class="xref">Section 9.2</a>, note SHOULD also be taken to <samp>jwks</samp> as the trust anchor MAY be performing a key rollover.  </p>
<h1 id="rfc.appendix.A.2.7">
<a href="#rfc.appendix.A.2.7">A.2.7.</a> Entity Statement Published by 'https://edugain.geant.org' about 'https://swamid.se'</h1>
<p id="rfc.section.A.2.7.p.1">The LIGO Wiki RP uses the federation API and the "fetch" command as defined in <a href="#fetch_statement" class="xref">Section 7.1.1</a> to fetch information about "https://swamid.se" from the API endpoint published in https://edugain.geant.org's configuration.  </p>
<p id="rfc.section.A.2.7.p.2">The request will look like this:</p>
<pre>
GET /edugain/api?sub=https%3A%2F%2Fswamid.se&amp;
iss=https%3A%2F%2Fedugain.geant.org HTTP/1.1
Host: geant.org
            </pre>
<p id="rfc.section.A.2.7.p.3">and the result is this:</p>
<pre>
{
  "exp": 1568397247,
  "iat": 1568310847,
  "iss": "https://edugain.geant.org",
  "jwks": {
    "keys": [
      {
        "e": "AQAB",
        "kid": "N1pQTzFxUXZ1RXVsUkVuMG5uMnVDSURGRVdhUzdO...",
        "kty": "RSA",
        "n": "3EQc6cR_GSBq9km9-WCHY_lWJZWkcn0M05TGtH6D9S..."
      }
    ]
  },
  "metadata_policy": {
    "openid_provider": {
      "contacts": {
        "add": "ops@edugain.geant.org"
      }
    },
    "openid_relying_party": {
      "contacts": {
        "add": "ops@edugain.geant.org"
      }
    }
  },
  "sub": "https://swamid.se"
}
</pre>
<p id="rfc.section.A.2.7.p.4">If we assume that the issuer of this statement appears in the list of trust anchors the LIGO Wiki RP has access to this would be the fourth and final entity statement in the trust chain.  </p>
<p id="rfc.section.A.2.7.p.5">We now have the whole chain from the self-signed entity statement of the leaf up until the last one that is issued by a trust anchor. All in all, we have: </p>

<ol>
<li>Self-signed entity statement by the leaf (https://op.umu.se) </li>
<li>Statement issued by https://umu.se about https://op.umu.se</li>
<li>Statement issued by https://swamid.se about https://umu.se</li>
<li>Statement issued by https://edugain.geant.org about https://swamid.se </li>
</ol>

<p> </p>
<p id="rfc.section.A.2.7.p.6">We also have the self-signed entity statements from https://umu.se, https://swamid.se and https://edugain.geant.org about themselves but those are not used in the trust chain verification.  </p>
<p id="rfc.section.A.2.7.p.7">Using the public keys of the trust anchor that the LIGO Wiki RP has been provided with in some secure out-of-band way, it can now verify the trust chain as described in <a href="#trust_chain_validation" class="xref">Section 8.2</a>.  </p>
<h1 id="rfc.appendix.A.2.8">
<a href="#rfc.appendix.A.2.8">A.2.8.</a> Verified Metadata for op.umu.se</h1>
<p id="rfc.section.A.2.8.p.1">Having verified the chain, the LIGO Wiki RP can proceed with the next step.  </p>
<p id="rfc.section.A.2.8.p.2">Combining the metadata policies from the tree entity statements we have by a superior about its subordinate and applying the combined policy to the metadata statement that the leaf entity presented, we get: </p>
<pre>
{
  "authorization_endpoint":
    "https://op.umu.se/openid/authorization",
  "claims_parameter_supported": false,
  "contacts": [
    "ops@swamid.se"
  ],
  "federation_registration_endpoint":
    "https://op.umu.se/openid/fedreg",
  "client_registration_type": [
    "automatic",
    "explicit"
  ],
  "grant_types_supported": [
    "authorization_code",
    "implicit",
    "urn:ietf:params:oauth:grant-type:jwt-bearer"
  ],
  "id_token_signing_alg_values_supported": [
    "RS256",
    "ES256"
  ],
  "issuer": "https://op.umu.se/openid",
  "jwks_uri": "https://op.umu.se/openid/jwks_uri.json",
  "logo_uri":
    "https://www.umu.se/img/umu-logo-left-neg-SE.svg",
  "organization_name": "University of Ume\u00e5",
  "op_policy_uri":
    "https://www.umu.se/en/website/legal-information/",
  "request_parameter_supported": false,
  "request_uri_parameter_supported": true,
  "require_request_uri_registration": true,
  "response_types_supported": [
    "code",
    "code id_token",
    "token"
  ],
  "subject_types_supported": [
    "pairwise"
  ],
  "token_endpoint": "https://op.umu.se/openid/token",
  "token_endpoint_auth_methods_supported": [
    "private_key_jwt",
    "client_secret_jwt"
  ],
  "version": "3.0"
}

</pre>
<p id="rfc.section.A.2.8.p.3">We have now reached the end of the Provider Discovery process.  </p>
<h1 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> The Two Ways of Doing Client Registration</h1>
<p id="rfc.section.A.3.p.1">As described in <a href="#client_registration" class="xref">Section 10</a>, there are two ways which can be used to do client registration: </p>

<dl>
<dt>Automatic</dt>
<dd style="margin-left: 8">
<br> No negotiation between the RP and the OP is made regarding what features the client SHOULD use in future communication are done. The RP's published metadata filtered by the chosen trust chain's metadata policies defines the metadata that is to be used.  </dd>
<dt>Explicit</dt>
<dd style="margin-left: 8">
<br> The RP will access the <samp>federation_registration_endpoint</samp>, which provides the metadata for the RP to use. The OP MAY return a metadata policy that adds restrictions over and above what the trust chain already has defined.  </dd>
</dl>

<p> </p>
<h1 id="rfc.appendix.A.3.1">
<a href="#rfc.appendix.A.3.1">A.3.1.</a> RP Sends Authentication Request (Automatic Registration)</h1>
<p id="rfc.section.A.3.1.p.1">The LIGO Wiki RP does not do any registration but goes directly to sending an Authentication Request.  </p>
<p id="rfc.section.A.3.1.p.2">Here is an example of such an Authentication Request: </p>
<pre>
GET /authorize?
  request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImRVTjJhMDF3Umtoa1NXc
    GxRVGh2Y1ZCSU5VSXdUVWRPVUZVMlRtVnJTbWhFUVhnelpYbHBUemRR
    TkEifQ.eyJyZXNwb25zZV90eXBlIjogImNvZGUiLCAic2NvcGUiOiAi
    b3BlbmlkIHByb2ZpbGUgZW1haWwiLCAiY2xpZW50X2lkIjogImh0dHB
    zOi8vd2lraS5saWdvLm9yZyIsICJzdGF0ZSI6ICIyZmY3ZTU4OS0zOD
    Q4LTQ2ZGEtYTNkMi05NDllMTIzNWU2NzEiLCAibm9uY2UiOiAiZjU4M
    WExODYtYWNhNC00NmIzLTk0ZmMtODA0ODQwODNlYjJjIiwgInJlZGly
    ZWN0X3VyaSI6ICJodHRwczovL3dpa2kubGlnby5vcmcvb3BlbmlkL2N
    hbGxiYWNrIiwgImlzcyI6ICIiLCAiaWF0IjogMTU5MzU4ODA4NSwgIm
    F1ZCI6ICJodHRwczovL29wLnVtdS5zZSJ9.cRwSFNcDx6VsacAQDcIx
    5OAt_Pj30I_uUKRh04N4QJd6MZ0f50sETRv8uspSt9fMa-5yV3uzthX
    _v8OtQrV33gW1vzgOSRCdHgeCN40StbzjFk102seDwtU_Uzrcsy7KrX
    YSBp8U0dBDjuxC6h18L8ExjeR-NFjcrhy0wwua7Tnb4QqtN0QCia6DD
    8QBNVTL1Ga0YPmMdT25wS26wug23IgpbZB20VUosmMGgGtS5yCI5AwK
    Bhozv-oBH5KxxHzH1Oss-RkIGiQnjRnaWwEOTITmfZWra1eHP254wFF
    2se-EnWtz1q2XwsD9NSsOEJwWJPirPPJaKso8ng6qrrOSgw
  &amp;response_type=code
  &amp;client_id=https%3A%2F%2Fwiki.ligo.org
  &amp;redirect_uri=https%3A%2F%2Fwiki.ligo.org/openid/callback
  &amp;scope=openid+profile+email
  HTTP/1.1
Host: op.umu.se
</pre>
<p id="rfc.section.A.3.1.p.3">The OP receiving this Authentication Request will, unless the RP is already registered, start to dynamically fetch and establish trust with the RP.  </p>
<h1 id="rfc.appendix.A.3.1.1">
<a href="#rfc.appendix.A.3.1.1">A.3.1.1.</a> OP Fetches Entity Statements</h1>
<p id="rfc.section.A.3.1.1.p.1">The OP needs to establish a trust chain for the RP (wiki.ligo.org).  The OP in this example is configured with public keys of two federations: </p>

<ul>
<li>https://edugain.geant.org</li>
<li>https://swamid.se</li>
</ul>

<p> </p>
<p id="rfc.section.A.3.1.1.p.2">The OP starts to resolve metadata for the client identifier https://wiki.ligo.org by fetching the self-issued entity statement using the process described in <a href="#federation_configuration" class="xref">Section 6</a>.  </p>
<p id="rfc.section.A.3.1.1.p.3">The process is the same as described in <a href="#op_discovery" class="xref">Appendix A.2</a> and will result in a trust chain with the following entity statements: </p>

<ol>
<li>Self-signed entity statement by the leaf https://wiki.ligo.org </li>
<li>Statement issued by https://incommon.org about https://wiki.ligo.org </li>
<li>Statement issued by https://edugain.geant.org about https://incommon.org </li>
</ol>

<p> </p>
<h1 id="rfc.appendix.A.3.1.2">
<a href="#rfc.appendix.A.3.1.2">A.3.1.2.</a> <a href="#rp_metadata_eval" id="rp_metadata_eval">OP Evaluates the RP Metadata</a>
</h1>
<p id="rfc.section.A.3.1.2.p.1">Using the public keys of the trust anchor that the LIGO Wiki RP has been provided with in some secure out-of-band way, it can now verify the trust chain as described in <a href="#trust_chain_validation" class="xref">Section 8.2</a>.  </p>
<pre>
"metadata_policy": {
  "openid_provider": {
    "contacts": {
      "add": "ops@edugain.geant.org"
    }
  },
  "openid_relying_party": {
    "contacts": {
      "add": "ops@edugain.geant.org"
    }
  }
}
                </pre>
<p id="rfc.section.A.3.1.2.p.2">We will not list the complete entity statements but only the <samp>metadata</samp> and <samp>metadata_policy</samp> parts.  There are two metadata policies: </p>

<dl>
<dt>edugain.geant.org</dt>
<dd style="margin-left: 8"></dd>
</dl>

<p> </p>
<pre>
"metadata_policy": {
  "openid_relying_party": {
    "application_type": {
      "one_of": [
        "web",
        "native"
      ]
    },
    "contacts": {
      "add": "ops@incommon.org"
    },
    "grant_types": {
      "subset_of": [
        "authorization_code",
        "refresh_token"
      ]
    }
  }
}
                </pre>
<p></p>

<dl>
<dt>incommon.org</dt>
<dd style="margin-left: 8"></dd>
</dl>

<p> </p>
<p id="rfc.section.A.3.1.2.p.4">If you combine these and apply them to the metadata for wiki.ligo.org : </p>
<pre>
"metadata": {
  "application_type": "web",
  "client_name": "LIGO Wiki",
  "contacts": [
    "ops@ligo.org"
  ],
  "grant_types": [
    "authorization_code",
    "refresh_token"
  ],
  "id_token_signing_alg_values_supported": [
    "RS256",
    "RS512"
  ],
  "jwks_uri": "https://wiki.ligo.org/jwks.json",
  "redirect_uris": [
    "https://wiki.ligo.org/callback"
  ],
  "response_types": [
    "code"
  ],
  "subject_type": "public"
}
</pre>
<p id="rfc.section.A.3.1.2.p.5">You will get </p>
<pre>
{
  "application_type": "web",
  "client_name": "LIGO Wiki",
  "contacts": [
    "ops@ligo.org",
    "ops@edugain.geant.org",
    "ops@incommon.org"
  ],
  "grant_types": [
    "refresh_token",
    "authorization_code"
  ],
  "id_token_signing_alg_values_supported": [
    "RS256",
    "RS512"
  ],
  "jwks_uri": "https://wiki.ligo.org/jwks.json",
  "redirect_uris": [
    "https://wiki.ligo.org/callback"
  ],
  "response_types": [
    "code"
  ],
  "subject_type": "public"
}
</pre>
<p id="rfc.section.A.3.1.2.p.6">Having that, the registration is done, and the OP MUST now use the keys found at the URL specified in <samp>jwks_uri</samp> to verify the signature on the Request Object in the Authentication Request.  </p>
<h1 id="rfc.appendix.A.3.2">
<a href="#rfc.appendix.A.3.2">A.3.2.</a> Client Starts with Registration (Explicit Client Registration)</h1>
<p id="rfc.section.A.3.2.p.1">Here the LIGO Wiki RP sends a client registration request to the <samp>federation_registration_endpoint</samp> of the OP (op.umu.se).  What it sends is a self-signed entity statement.  </p>
<p id="rfc.section.A.3.2.p.2">Once the OP has the entity statement, it proceeds with the same sequence of steps as laid out in <a href="#op_discovery" class="xref">Appendix A.2</a>.  </p>
<p id="rfc.section.A.3.2.p.3">The OP will end up with the same RP metadata as was described in <a href="#rp_metadata_eval" class="xref">Appendix A.3.1.2</a>, but what it now can do is return a metadata policy that it wants to be applied to the RP's metadata. This metadata policy will be combined with the trust chain's combined metadata policy before being applied to the RP's metadata.  </p>
<p id="rfc.section.A.3.2.p.4">If we assume that the OP does not support refresh tokens, it MAY want to add a metadata policy that says: </p>
<pre>
"metadata_policy": {
  "openid_relying_party": {
    "grant_types": {
      "subset_of": [
        "authorization_code"
      ]
    }
  }
}
</pre>
<p id="rfc.section.A.3.2.p.5">Thus, the entity statement returned by the OP to the RP MAY look like this: </p>
<pre>

{
  "trust_anchor_id": "https://edugain.geant.org",
  "metadata_policy": {
    "openid_relying_party": {
      "application_type": {
        "one_of": [
          "web",
          "native"
        ]
      },
      "contacts": {
        "add": [
          "ops@incommon.org",
          "ops@edugain.geant.org"
        ]
      },
      "grant_types": {
        "subset_of": [
          "authorization_code",
          "refresh_token"
        ]
      }
      "registration_access_token": {
        "value": "nLe19cJ5e9SXXiPqnRRuxpjyWI73bDhD"
      },
      "client_id": {
        "value": "m3GyHw"
      },
      "client_secret_expires_at": {
        "value": 1604049619
      },
      "registration_client_uri": {
        "value":
          "https://op.umu.se/openid/registration?client_id=m3GyHw"
      },
      "client_secret": {
        "value":
          "cb44eed577f3b5edf3e08362d47a0dc44630b3dc6ea99f7a79205"
      },
      "client_id_issued_at": {
        "value": 1601457619
      }
    }
  },
  "authority_hints": [
    "https://incommon.org"
  ],
  "aud": "https://wiki.ligo.org",
  "jwks": {
    "keys": [
      {
        "kty": "RSA",
        "use": "sig",
        "kid":
          "U2JTWHY0VFg0a2FEVVdTaHptVDJsNDNiSDk5MXRBVEtNSFVkeXZwb",
        "e": "AQAB",
        "n":
          "4AZjgqFwMhTVSLrpzzNcwaCyVD88C_Hb3Bmor97vH-2AzldhuVb8K..."
      },
      {
        "kty": "EC",
        "use": "sig",
        "kid": "LWtFcklLOGdrW",
        "crv": "P-256",
        "x": "X2S1dFE7zokQDST0bfHdlOWxOc8FC1l4_sG1Kwa4l4s",
        "y": "812nU6OCKxgc2ZgSPt_dkXbYldG_smHJi4wXByDHc6g"
      }
    ]
  },
  "iss": "https://op.umu.se",
  "iat": 1601457619,
  "exp": 1601544019
}
</pre>
<p id="rfc.section.A.3.2.p.6">And the resulting metadata used by the RP could look like: </p>
<pre>
{
  "application_type": "web",
  "client_name": "LIGO Wiki",
  "contacts": [
    "ops@edugain.geant.org",
    "ops@incommon.org",
    "ops@ligo.org"
  ],
  "grant_types": [
    "authorization_code"
  ],
  "id_token_signing_alg_values_supported": [
    "RS256",
    "RS512"
  ],
  "jwks_uri": "https://wiki.ligo.org/jwks.json",
  "redirect_uris": [
    "https://wiki.ligo.org/callback"
  ],
  "response_types": [
    "code"
  ],
  "subject_type": "public"
}
</pre>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#Notices" id="Notices">Notices</a>
</h1>
<p id="rfc.section.B.p.1">Copyright (c) 2021 The OpenID Foundation.  </p>
<p id="rfc.section.B.p.2">The OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce, prepare derivative works from, distribute, perform and display, this Implementers Draft or Final Specification solely for the purposes of (i) developing specifications, and (ii) implementing Implementers Drafts and Final Specifications based on such documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.  </p>
<p id="rfc.section.B.p.3">The technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual Property Rights policy requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers. The OpenID Foundation invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that MAY cover technology that MAY be required to practice this specification.  </p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.C.p.1">The authors wish to acknowledge the contributions of the following individuals and organizations to this specification: Vladimir Dzhuvinov, Heather Flanagan, Jouke Roorda, Mischa Sall&#233;, Marcos Sanz, Peter Schober, Michael Schwartz, and the JRA3T3 task force of GEANT4-2.  </p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#TBD" id="TBD">Open Issues</a>
</h1>
<p id="rfc.section.D.p.1">The following open issues remain to be addressed in this specification.  </p>
<p></p>

<ul>
<li>The representation for RPs that are native applications needs to be defined.  </li>
<li>How are federation operator keys retrieved? </li>
<li>A mechanism is needed for key rotation of federation operator keys for long-term security and maintainability of federations.  </li>
<li>A mechanism MAY be needed for bounding key lifetimes.  </li>
<li>Discuss that Key IDs MAY be chosen as the JWK Thumbprint [RFC 7638] of the key.  </li>
<li>Discuss localization of human-readable strings.  </li>
<li>SAML2 as used in Research and Education federations uses post-/prefix matching on metadata in some cases. We might need something similar or just use regular expressions.  </li>
<li>Define the relationship between trust anchors and Federation Operators, as people will expect to find the Federation Operator term in the specification.  </li>
<li>Add a diagram showing the relationships between FOs, orgs, sub-orgs, and leaf entities.  </li>
</ul>

<p> </p>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#History" id="History">Document History</a>
</h1>
<p id="rfc.section.E.p.1">[[ To be removed from the final specification ]]</p>
<p id="rfc.section.E.p.2">-17 </p>

<ul><li>Addressed many working group review comments.  Changes included adding the Overall Architecture section, the <samp>trust_marks_issuers</samp> claim, and the Setting Up a Federation section.  </li></ul>

<p> </p>
<p id="rfc.section.E.p.3">-16 </p>

<ul><li>Added Security Considerations section on Denial of Service attacks.  </li></ul>

<p> </p>
<p id="rfc.section.E.p.4">-15 </p>

<ul><li>Added <samp>signed_jwks_uri</samp>, which had been lost somewhere along the road.  </li></ul>

<p> </p>
<p id="rfc.section.E.p.5">-14 </p>

<ul>
<li>Rewrote the federation policy section.  </li>
<li>What previously was referred to as <samp>client authentication</samp> in connection with automatic client registration is now changed to be <samp>request authentication</samp>.  </li>
<li>Made a distinction between parameters and claims.  </li>
<li>Corrected the description of the intended behavior when <samp>essential</samp> is absent.  </li>
</ul>

<p> </p>
<p id="rfc.section.E.p.6">-13 </p>

<ul>
<li>Added 'trust_marks' as a parameter in the entity statement.  </li>
<li>An RP's self-signed entity statement MUST have the OP's issuer identifier as the value of 'aud'.  </li>
<li>Added RS256 as default signing algorithm for entity statements.  </li>
<li>Specified that the value of 'aud' in the entity statement use in automatic client registration MUST have the ASs authorization endpoint URL as value. Also the 'sub' claim MUST NOT be present.  </li>
<li>Separating the usage of merge and combine as proposed by Vladimir Dzhuvinov in Bitbucket issue #1157.  </li>
<li>An RP doing only explicit client registration are not required to publish and support a .well-known/openid-federation endpoint.  </li>
<li>Every key in a JWK Set in an entity statement MUST have a kid.  </li>
</ul>

<p> -12 </p>

<ul>
<li>Made JWK Set OPTIONAL in an entity statement returned by OP as response of an explicit client registration </li>
<li>Renamed entity type to client registration type.  </li>
<li>Added more text describing client_registration_auth_methods_supported.  </li>
<li>Made "Processing the Authentication Request" into two separate sections: one for Authentication Request and one for Pushed Authorization Request.  </li>
<li>Added example of URLs to some examples in the appendix.  </li>
<li>Changed the automatic client registration example in the appendix to use Request Object instead of a client_assertion.  </li>
</ul>

<p> </p>
<p id="rfc.section.E.p.7">-11 </p>

<ul>
<li>Added section on trust marks.  </li>
<li>Clarified private_key_jwt usage in the authentication request.  </li>
<li>Fixed Bitbucket issues #1150 and #1155 by Vladimir Dzhuvinov.  </li>
<li>Fixed some examples to make them syntactically correct.  </li>
</ul>

<p> </p>
<p id="rfc.section.E.p.8">-10 </p>

<ul><li>Incorporated additional review feedback from Marcos Sanz.  The primary change was moving constraints to their own section of the entity statement.  </li></ul>

<p> </p>
<p id="rfc.section.E.p.9">-09 </p>

<ul>
<li>Incorporated review feedback from Marcos Sanz.  Major changes were as follows.  </li>
<li>Separated entity configuration discovery from operations provided by the federation API.  </li>
<li>Defined new authentication error codes.  </li>
<li>Also incorporated review feedback from Michael B. Jones.  </li>
</ul>

<p> </p>
<p id="rfc.section.E.p.10">-08 </p>

<ul>
<li>Incorporated review feedback from Michael B. Jones.  Major changes were as follows.  </li>
<li>Deleted <samp>sub_is_leaf</samp> entity statement since it was redundant.  </li>
<li>Added <samp>federation_type</samp> RP registration metadata value and <samp>federation_types_supported</samp> OP metadata value.  </li>
<li>Deleted <samp>openid_discovery</samp> metadata type identifier since its purpose is already served by <samp>openid_provider</samp>.  </li>
<li>Entity identifier paths are now included when using the Federation API, enabling use in multi-tenant deployments sharing a common domain name.  </li>
<li>Renamed <samp>sub_is_leaf</samp> to <samp>is_leaf</samp> in the Entity Listings Request operation parameters.  </li>
<li>Added <samp>crit</samp> and <samp>policy_language_crit</samp>, enabling control over which entity statement and policy language extensions MUST be understood and processed.  </li>
<li>Renamed <samp>openid_client</samp> to <samp>openid_relying_party</samp>.  </li>
<li>Renamed <samp>oauth_service</samp> to <samp>oauth_authorization_server</samp>.  </li>
<li>Renamed <samp>implicit</samp> registration to <samp>automatic</samp> registration to avoid naming confusion with the implicit grant type.  </li>
<li>Renamed <samp>op</samp> to <samp>operation</samp> to avoid naming confusion with the use of "OP" as an acronym for "OpenID Provider".  </li>
<li>Renamed <samp>url</samp> to <samp>uri</samp> in several identifiers.  </li>
<li>Restored Open Issues appendix.  </li>
<li>Corrected document formatting issues.  </li>
</ul>

<p> </p>
<p id="rfc.section.E.p.11">-07 </p>

<ul>
<li>Split metadata into metadata and metadata_policy </li>
<li>Updated example </li>
</ul>

<p> </p>
<p id="rfc.section.E.p.12">-06 </p>

<ul>
<li>Some rewrites </li>
<li>Added example of explicit client registration </li>
</ul>

<p> </p>
<p id="rfc.section.E.p.13">-05 </p>

<ul><li>A major rewrite.  </li></ul>

<p> </p>
<p id="rfc.section.E.p.14">-04 </p>

<ul>
<li>Changed client metadata names <samp>scopes</samp> to <samp>rp_scopes</samp> and <samp>claims</samp> to <samp>rp_claims</samp>.  </li>
<li>Added Open Issues appendix.  </li>
<li>Added additional references.  </li>
<li>Editorial improvements.  </li>
<li>Added standard Notices section, which is present in all OpenID specifications.  </li>
</ul>

<p> </p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Roland Hedberg</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Hedberg</span>
	  </span>
	</span>
	<span class="org vcardline">independent</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:roland@catalogix.se">roland@catalogix.se</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael B. Jones</span> 
	  <span class="n hidden">
		<span class="family-name">Jones</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbj@microsoft.com">mbj@microsoft.com</a></span>

<span class="vcardline">URI: <a href="http://self-issued.info/">http://self-issued.info/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Andreas &#197;kre Solberg</span> 
	  <span class="n hidden">
		<span class="family-name">Solberg</span>
	  </span>
	</span>
	<span class="org vcardline">Uninett AS</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:andreas.solberg@uninett.no">andreas.solberg@uninett.no</a></span>

<span class="vcardline">URI: <a href="https://www.linkedin.com/in/andreassolberg/">https://www.linkedin.com/in/andreassolberg/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Samuel Gulliksson</span> 
	  <span class="n hidden">
		<span class="family-name">Gulliksson</span>
	  </span>
	</span>
	<span class="org vcardline">Schibsted Media Group</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:samuel.gulliksson@gmail.com">samuel.gulliksson@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Bradley</span> 
	  <span class="n hidden">
		<span class="family-name">Bradley</span>
	  </span>
	</span>
	<span class="org vcardline">Yubico</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ve7jtb@ve7jtb.com">ve7jtb@ve7jtb.com</a></span>

<span class="vcardline">URI: <a href="http://www.thread-safe.com/">http://www.thread-safe.com/</a></span>

  </address>
</div>

</body>
</html>
